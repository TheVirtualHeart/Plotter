{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///plotter.js","webpack:///webpack/bootstrap 4c93c2d5cf8c4e42ee36","webpack:///./src/entry.js","webpack:///./src/point.js","webpack:///./src/line.js","webpack:///./src/plot.js","webpack:///./src/plotter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Point","Line","Plot","px","py","x","y","pa","pb","s","a","b","point","slope","createPlotter","pageToPlot","plot","settings","canvas","offsetLeft","offset","pixelPerUnit","domain","height","offsetTop","plotSize","range","pointInBounds","findPlotUnderPoint","i","plots","length","updateMouse","e","pageX","pageY","type","replace","buttons","button","mouse","isDown","isUp","updateTouch","changedTouches","event","MouseEvent","screenX","screenY","clientX","clientY","dispatchEvent","touches","preventDefault","refitCanvas","clipped","ctx","restore","size","Math","max","labelBleed","labelSize","width","padding","strokeStyle","lineWidth","strokeRect","drawPlot","translate","clearRect","debugBorders","fillStyle","fillRect","font","textAlign","textBaseline","beginPath","gridSize","orientation","drawGrid","moveTo","lineTo","labelFrequency","tickLabel","unitPerTick","fillText","labelPrecision","toFixed","stroke","axisOffset","zeroBoundAxis","min","xAxis","rotate","PI","yAxis","drawCoords","coordOffsetY","measureText","coordOffsetX","isNaN","round","move","currentPlot","plotNames","arguments","getContext","addEventListener","drawBorders","value","newPlot","name","push","clearPlot","unclip","undefined","save","rect","clip","editPlot","reCalcLabels","redrawCanvas","String","constructor","Object","prototype","toString","key","hasOwnProperty","reCalculateLabels","selectPlot","clear","pointOnPlot","plotToCanvas","plotPoint","r","fill","arc","plotLine","p1","p2","lineCap","plotSlope","plotPoly","points","closed","keys","plotFunction","func","xFunc","step","start","end","funcValue","plotText","text","printPlotData","pointObject","fields","csv","getPoints","header","j","window","open","encodeURIComponent"],"mappings":"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","file":"plotter.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports.Point = __webpack_require__(1);\n\tmodule.exports.Line = __webpack_require__(2);\n\tmodule.exports.Plot = __webpack_require__(3);\n\tmodule.exports = __webpack_require__(4);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A generic object for holding a point\n\t * @param {number} px - the x coordinate of the point\n\t * @param {number} py - the y coordinate of the point\n\t */\n\tfunction Point(px, py) {\n\t\tthis.x = px; \n\t\tthis.y = py;\n\t}\n\t\n\tmodule.exports = Point;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A generic object for holding a line.\n\t * @param {Point} pa - the first point on the line (used for calculating a line based on two points)\n\t * @param {Point} pb - the second point on the line (used for calculating a line based on two points)\n\t * @param {number} s - the slope of the line (used for calculating a line based on point-slope)\n\t * @param {Point} p - the point on the line (used for calculating a line based on point-slope)\n\t */\n\tfunction Line(pa, pb, s, p) {\n\t\tthis.a = pa; \n\t\tthis.b = pb; \n\t\tthis.point = p; \n\t\tthis.slope = s;\n\t} \n\t\n\tmodule.exports = Line;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Point = __webpack_require__(1);\n\t\n\t/**\n\t * Plots are what Points (and objects that consist of Points) are rendered on.\n\t * Plots describe the context in which Points are drawn, holding information\n\t * such as labels and a local coordinate system. Plotter uses this information\n\t * when plotting points and other objects.\n\t */\n\tfunction Plot()\n\t{\n\t\tvar ctx = arguments[1];\t\t\t\t\t\t\t// the context in which the \n\t\tvar settings = arguments[0];\n\t\t\n\t\tvar offsetVar = new Point(0, 0);\n\t\tvar domainVar = new Point(-10, 10);\n\t\tvar rangeVar = new Point(-10, 10);\n\t\tvar plotSizeVar = new Point(0, 0);\n\t\tvar pixelPerUnitVar = new Point(10, 10);\n\t\tvar unitPerTickVar = new Point(1, 1);\n\t\tvar labelFrequencyVar = new Point(2, 2);\n\t\tvar labelSizeVar = new Point(0, 0);\n\t\tvar labelBleedVar = new Point(0, 0);\n\t\tvar labelPrecisionVar = new Point(-1, -1);\n\t\t\n\t\n\t\t/**\n\t\t * Plot is a module. All variables enclosed are inaccesible from the \n\t\t * outside. self is returned to expose some of these variables\n\t\t * @type {Object}\n\t\t */\n\t\tvar self = {\t\n\t\n\t\n\t\t\t/**\n\t\t\t * @property {object} settings - a collection of settings that affect\n\t\t\t * how the plot is rendered\n\t\t\t * \n\t\t\t * @property {Point} settings.offset - by default, a graph is rendered \n\t\t\t * in the upper left corner of the canvas. This allows you to \n\t\t\t * reposition the plot relative to this point.\n\t\t\t *\n\t\t\t * @property {Point} settings.domain - the points along the x-axis that\n\t\t\t * the plot will display\n\t\t\t *\n\t\t\t * @property {Point} settings.range - the points along the y-axis that \n\t\t\t * the plot will display\n\t\t\t *\n\t\t\t * @property {Point} settins.pixelPerUnit - The number of pixels that \n\t\t\t * each unit of the plot will take up\n\t\t\t *\n\t\t\t * @property {Point} settings.plotSize - (readonly) The size of the \n\t\t\t * plot in pixels. This value is calculated by multiplying the pixels \n\t\t\t * per unit by the number of units in the graph (domain end - domain \n\t\t\t * start and range end - range start)\n\t\t\t *\n\t\t\t * @property {Point} settings.unitPerTick - A tick is wherever a line is drawn\n\t\t\t * on the plot. This controls how many units must pass before a tick is\n\t\t\t * drawn\n\t\t\t *\n\t\t\t * @property {Point} settings.gridSize - (readonly) The size of each block of \n\t\t\t * ticks on the plot. Calculated by multiplying the pixelPerUnit by the\n\t\t\t * unitPerTick\n\t\t\t *\n\t\t\t * @property {Point} settings.labelFrequency - This is the rate at which labels\n\t\t\t * are drawn on the ticks. It will default to a label for every tick\n\t\t\t *\n\t\t\t * @property {Point} settings.labelSize - (readonly) The size of the \n\t\t\t * label, where x is width and y is height, as calculated by \n\t\t\t * calculateLabelSize()\n\t\t\t *\n\t\t\t * @property {Point} settings.labelBleed - (readonly)\n\t\t\t *\n\t\t\t * @property {Point} settings.labelPrecision - This is a point that \n\t\t\t * determines how many decimals trail after the \".\" character. Values\n\t\t\t * less than 0 disable this feature.\n\t\t\t *\n\t\t\t * @property {string} settings.xAxis - the label for the x axis\n\t\t\t *\n\t\t\t * @property {string} settings.yAxis - the label for the y axis\n\t\t\t * \n\t\t\t * @property {boolean} settings.zeroBoundAxis - determines whether a \n\t\t\t * thick black line is drawn around the 0 axis. If false, the thick\n\t\t\t * black line will be drawn around the edges of the graph.\n\t\t\t * \n\t\t\t * @property {boolean} settings.drawGrid - determines whether the \n\t\t\t *\n\t\t\t * @property {boolean} settings.drawCoords - If true, the mouse\n\t\t\t * coordinates will be rendered. CURRENTLY NOT WORKING.\n\t\t\t * \n\t\t\t * @property {string} settings.orientation - determines where the\n\t\t\t * origin of the graph is rendered. It starts at the bottom left and\n\t\t\t * goes counterclockwise. \"a\" is the bottom left, \"b\" is the top left,\n\t\t\t * \"c\" is the top right, \"d\" is the bottom right.\n\t\t\t */\n\t\t\tsettings:\n\t\t\t{\n\t\t\t\tset offset(value) \n\t\t\t\t{\n\t\t\t\t\toffsetVar.x = value.x;\n\t\t\t\t\toffsetVar.y = value.y;\n\t\t\t\t},\n\t\t\t\tget offset() { return new Point(offsetVar.x + 75, offsetVar.y + 20); },\n\t\t\t\tset domain(value)\n\t\t\t\t{\n\t\t\t\t\tdomainVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\t\tdomainVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\t},\n\t\t\t\tget domain() { return new Point(domainVar.x, domainVar.y); },\n\t\t\t\tset range(value)\n\t\t\t\t{\n\t\t\t\t\trangeVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\t\trangeVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t\t},\n\t\t\t\tget range() { return new Point(rangeVar.x, rangeVar.y); },\n\t\t\t\tset pixelPerUnit(value)\n\t\t\t\t{\n\t\t\t\t\tpixelPerUnitVar.x = value.x != 0 ? value.x : pixelPerUnitVar.x;\n\t\t\t\t\tpixelPerUnitVar.y = value.y != 0 ? value.y : pixelPerUnitVar.y;\n\t\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t\t},\n\t\t\t\tget pixelPerUnit() { return new Point(pixelPerUnitVar.x, pixelPerUnitVar.y); },\n\t\t\t\tget plotSize() { return new Point(plotSizeVar.x, plotSizeVar.y); },\n\t\t\t\tset unitPerTick(value)\n\t\t\t\t{\n\t\t\t\t\tunitPerTickVar.x = value.x != 0 ? value.x : unitPerTickVar.x;\n\t\t\t\t\tunitPerTickVar.y = value.y != 0 ? value.y : unitPerTickVar.y;\n\t\t\t\t},\n\t\t\t\tget unitPerTick() { return new Point(unitPerTickVar.x, unitPerTickVar.y); },\n\t\t\t\tget gridSize()\n\t\t\t\t{ return new Point(this.unitPerTick.x * this.pixelPerUnit.x, this.unitPerTick.y * this.pixelPerUnit.y); },\n\t\t\t\tset labelFrequency(value)\n\t\t\t\t{\n\t\t\t\t\tlabelFrequencyVar.x = value.x >= 0 ? value.x : 0;\n\t\t\t\t\tlabelFrequencyVar.y = value.y >= 0 ? value.y : 0;\n\t\t\t\t},\n\t\t\t\tget labelFrequency() { return new Point(labelFrequencyVar.x, labelFrequencyVar.y); },\n\t\t\t\tget labelSize() { return new Point(labelSizeVar.x, labelSizeVar.y); },\n\t\t\t\tget labelBleed() { return new Point(labelBleedVar.x, labelBleedVar.y); },\n\t\t\t\tset labelPrecision(value)\n\t\t\t\t{\n\t\t\t\t\tlabelPrecisionVar.x = value.x >= 0 ? Math.min(20, Math.max(0, value.x)) : -1;\n\t\t\t\t\tlabelPrecisionVar.y = value.y >= 0 ? Math.min(20, Math.max(0, value.y)) : -1;\n\t\t\t\t},\n\t\t\t\tget labelPrecision() { return new Point(labelPrecisionVar.x, labelPrecisionVar.y); },\n\t\t\t\txAxis: \"xAxis\",\n\t\t\t\tyAxis: \"yAxis\",\n\t\t\t\tzeroBoundAxis: true,\n\t\t\t\tdrawGrid: true,\n\t\t\t\tdrawCoords: false,\n\t\t\t\torientation: \"a\"\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * @property {object} mouse - a collection of settings related to the \n\t\t\t * mouse in relation to the plot.\n\t\t\t *\n\t\t\t * @property {Point} mouse.down - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.move - The point in the plot's local\n\t\t\t * coordinates where the mouse has moved to\t \n\t\t\t * \n\t\t\t * @property {Point} mouse.up - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.isDown - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.isUp - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t */\n\t\t\tmouse:\n\t\t\t{\n\t\t\t\tdown: new Point(),\n\t\t\t\tmove: new Point(),\n\t\t\t\tup: new Point(),\n\t\t\t\tisDown: false,\n\t\t\t\tisUp: true\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Recalculate the size of the labels and the label bleed.\n\t\t\t */\n\t\t\treCalculateLabels: function() { \n\t\t\t\tcalculateLabelSize(); \n\t\t\t\tcalculateLabelBleed(); \n\t\t\t}\n\t\t}\n\t\t\n\t\t/**  \n\t\t * This initializes the Plot, merging the default settings object with the\n\t\t * object that was passed to the function as an argument. It then calculates\n\t\t * the size of the plot and the labels.\n\t\t */\n\t\tfor (var key in settings)\n\t\t\tif (self.settings.hasOwnProperty(key))\n\t\t\t\tself.settings[key] = settings[key];\n\t\t\n\t\tplotSizeVar.x = self.settings.pixelPerUnit.x * (self.settings.domain.y - self.settings.domain.x);\n\t\tplotSizeVar.y = self.settings.pixelPerUnit.y * (self.settings.range.y - self.settings.range.x);\n\t\t\n\t\tcalculateLabelSize();\n\t\tcalculateLabelBleed();\n\t\t\n\t\n\t\t/**\n\t\t * This function calculates padding that labels add to the graph. This is the\n\t\t * entire block of labels on each axis. It determines what the maximum \n\t\t * length of the value labels would be on each axis and then adds padding to \n\t\t * encompass the label of the axis.\n\t\t */\n\t\tfunction calculateLabelSize()\n\t\t{\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar s = self.settings;\n\t\t\t\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tvar labelPadding = ctx.measureText(\"M.\").width;\n\t\t\t\n\t\t\tif (s.labelFrequency.y != 0) {\n\t\t\t\tx += Math.max(ctx.measureText(s.range.x).width, ctx.measureText(s.range.x + Math.floor(s.plotSize.y / s.gridSize.y) * s.unitPerTick.y).width);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx += 6;\n\t\t\t}\n\t\t\tif (s.yAxis != \"\") {\n\t\t\t\tx += labelPadding;\n\t\t\t}\n\t\n\t\t\tif (s.labelFrequency.x != 0) {\n\t\t\t\ty += labelPadding;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty += 6;\n\t\t\t}\n\t\t\tif (s.xAxis != \"\") {\n\t\t\t\ty += labelPadding;\n\t\t\t}\n\t\t\tif (s.yAxis != \"\")\n\t\t\t{\n\t\t\t\tctx.font = \"24px Helvetica\";\n\t\t\t\tvar yBleed = ctx.measureText(s.yAxis).width * 0.5 - s.plotSize.y * 0.5;\n\t\t\t\ty = yBleed > y ? yBleed : y;\n\t\t\t}\n\t\t\t\n\t\t\tlabelSizeVar.x = x;\n\t\t\tlabelSizeVar.y = y;\n\t\t}\n\t\t\n\t\n\t\t/**\n\t\t * This function calculates the \"bleed\" of the labels. Essentially, if a \n\t\t * label value overflows, this provides a cutoff after which it will stop\n\t\t * rendering the text.\n\t\t * @return {[type]} [description]\n\t\t */\n\t\tfunction calculateLabelBleed()\n\t\t{\n\t\t\tvar s = self.settings;\n\t\t\tvar x = 0;\n\t\t\tvar y = s.labelFrequency.y != 0 ? -8 : 0;\n\t\t\t\n\t\t\tctx.font = \"16px Helvetica\";\n\t\t\t\n\t\t\tif (s.labelFrequency.x != 0) {\n\t\t\t\tx =  Math.max(s.offset.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.gridSize.x + ctx.measureText(s.domain.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.unitPerTick.x).width * 0.5 - (s.offset.x + s.plotSize.x), 0);\n\t\t\t}\n\t\t\t\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\t\n\t\t\tif (s.xAxis != \"\")\n\t\t\t{ \n\t\t\t\tvar axisBleed = Math.max(((s.domain.y - s.domain.x) * s.pixelPerUnit.x * 0.5 + ctx.measureText(s.xAxis).width * 0.5) - ((s.domain.y - s.domain.x) * s.pixelPerUnit.x), 0);\n\t\t\t\tx = x > axisBleed ? x : axisBleed;\n\t\t\t}\n\t\t\t\n\t\t\tif (s.yAxis != \"\")\n\t\t\t{\n\t\t\t\tvar yLabelBleed = s.plotSize.y * 0.5 - ctx.measureText(s.yAxis).width * 0.5;\n\t\t\t\ty = yLabelBleed < y ? yLabelBleed : y;\n\t\t\t}\n\t\t\t\n\t\t\tlabelBleedVar.x = x;\n\t\t\tlabelBleedVar.y = y;\n\t\t}\n\t\t\n\t\treturn self;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Point = __webpack_require__(1);\n\tvar Plot = __webpack_require__(3);\n\tvar Line = __webpack_require__(2);\n\t\n\t/**\n\t * Creates a Plotter object. Given a HTML Canvas Element, this function creates\n\t * a series of functions for interacting with it. It also attaches some of\n\t * these functions to event listeners for mouse and touch events.\n\t *\n\t * @param {HTMLCanvasElement} canvas - The Canvas element that plots will be\n\t * drawn on.\n\t *\n\t * @param {Point} padding - a Point that describs how much padding\n\t * to apply to the canvas element before rendering elements.\n\t * \n\t * @return {Plotter} - An object that collects properties and methods for \n\t * interacting with the canvas element passed to the function.\n\t */\n\tfunction createPlotter()\n\t{\n\t\tvar canvas, ctx;\n\t\tvar plots = [];\n\t\tvar plotNames = {};\n\t\tvar currentPlot, clipped = false;\n\t\tvar debugBorders = false;\n\t\tvar padding = typeof arguments[1] !== \"undefined\" ? arguments[1] : new Point(0, 0);\n\t\t\n\t\tcanvas = arguments[0];\n\t\tctx = canvas.getContext(\"2d\");\n\t\t\t\n\t\tcanvas.addEventListener(\"mousedown\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"mousemove\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"mouseup\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"touchstart\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchmove\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchend\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchcancel\", function(e){updateTouch(e);}, false);\n\t\t\n\t\tfunction pageToPlot(p, plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\tvar x = (p.x - canvas.offsetLeft - s.offset.x) / s.pixelPerUnit.x + s.domain.x;\n\t\t\tvar y = (canvas.height - (p.y - canvas.offsetTop) - (canvas.height - (s.offset.y + s.plotSize.y))) / s.pixelPerUnit.y + s.range.x;\n\t\t\treturn new Point(x, y);\n\t\t}\n\t\t\n\t\tfunction pointInBounds(p, plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\treturn (p.x >= s.domain.x && p.x <= s.domain.y && p.y >= s.range.x && p.y <= s.range.y)\n\t\t}\n\t\t\n\t\tfunction findPlotUnderPoint(p)\n\t\t{\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t\tif (pointInBounds(pageToPlot(p, plots[i]), plots[i]))\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfunction updateMouse(e)\n\t\t{\n\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\tif (plot == -1)\n\t\t\t\treturn;\n\t\t\tplot = plots[plot];\n\t\t\t\n\t\t\tvar p = pageToPlot(new Point(e.pageX, e.pageY), plot);\n\t\t\tvar type = e.type.replace(\"mouse\", '');\n\t\t\t\n\t\t\tif ((type == \"down\" || type == \"move\") && (!(e.buttons & 1) && e.button != 0))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tplot.mouse[type].x = p.x;\n\t\t\tplot.mouse[type].y = p.y;\n\t\t\tif (type == \"down\")\n\t\t\t{\n\t\t\t\tplot.mouse.isDown = true;\n\t\t\t\tplot.mouse.isUp = false;\n\t\t\t}\n\t\t\telse if (type == \"up\")\n\t\t\t{\n\t\t\t\tplot.mouse.isDown = false;\n\t\t\t\tplot.mouse.isUp = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction updateTouch(e)\n\t\t{\t\n\t\t\tvar type = e.type.replace(\"touch\",'');\n\t\t\t\n\t\t\tfor(var i = 0; i < e.changedTouches.length; i++)\n\t\t\t{\n\t\t\t\tvar touchID, event;\n\t\t\t\t\n\t\t\t\tswitch(type)\n\t\t\t\t{\n\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mousedown\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"move\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mousemove\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"cancel\":\n\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mouseup\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcanvas.dispatchEvent(event);\n\t\t\t}\n\t\t\t\n\t\t\tif (e.touches.length > 0)\n\t\t\t{\n\t\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\t\tif (plot != -1)\n\t\t\t\t{\n\t\t\t\t\tplots[plot].mouse.isDown = true;\n\t\t\t\t\tplots[plot].mouse.isUp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (e.touches.length == 1 && type == \"move\")\n\t\t\t\te.preventDefault();\n\t\t}\n\t\t\n\t\tfunction refitCanvas()\n\t\t{\n\t\t\tif (plots.length == 0)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.restore();\n\t\t\t\tclipped = false;\n\t\t\t}\n\t\t\t\n\t\t\tvar size = new Point(0, 0);\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t{\n\t\t\t\tvar s = plots[i].settings;\n\t\t\t\tsize.x = Math.max(size.x, s.offset.x + s.plotSize.x + s.labelBleed.x);\n\t\t\t\tsize.y = Math.max(size.y, s.offset.y + s.plotSize.y + s.labelSize.y);\n\t\t\t}\t\t\t\n\t\t\tcanvas.width = size.x + padding.x + 10;\n\t\t\tcanvas.height = size.y + padding.y + 10;\n\t\t\t\n\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\tctx.lineWidth = 2;\n\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t\tdrawPlot(plots[i]);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Renders the specified plot on the canvas. This function takes a Plot\n\t\t * object and then uses its settings to draw it on the canvas.\n\t\t * @param  {Plot} plot - the Plot object we want to render on the canvas\n\t\t */\n\t\tfunction drawPlot(plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\t\n\t\t\tctx.translate(s.offset.x, s.offset.y);\n\t\t\tctx.clearRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t\tif (debugBorders)\n\t\t\t{\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t\t}\t\n\t\t\tctx.lineWidth = 2;\n\t\t\t\n\t\t\t//plot\n\t\t\tctx.fillStyle = \"#F8F8F8\";\n\t\t\tctx.fillRect(0, 0, s.plotSize.x, s.plotSize.y);\n\t\t\tctx.fillStyle = \"#000000\";\n\t\t\tctx.strokeStyle = \"#E0E0E0\";\n\t\t\tctx.font = \"16px Helvetica\";\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.beginPath();\n\t\t\t\tfor( var i = 0; i <= s.plotSize.x / s.gridSize.x; i++)\n\t\t\t\t{\n\t\t\t\t\tvar x = i * s.gridSize.x;\n\t\t\t\t\tif (s.orientation==\"c\" || s.orientation==\"d\")\n\t\t\t\t\t\tx = s.plotSize.x - x;\n\t\t\t\t\t\n\t\t\t\t\tif (s.drawGrid)\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.moveTo(x, s.plotSize.y);\n\t\t\t\t\t\tctx.lineTo(x, 0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!(i % s.labelFrequency.x) && s.labelFrequency.x > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tickLabel = s.domain.x + i * s.unitPerTick.x;\n\t\t\t\t\t\tctx.fillText( s.labelPrecision.x == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.x), x, s.plotSize.y + 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\tctx.textBaseline = \"middle\";\n\t\t\t\tfor( var i = 0; i <= s.plotSize.y / s.gridSize.y; i++)\n\t\t\t\t{\n\t\t\t\t\tvar y = i * s.gridSize.y;\n\t\t\t\t\tif (!(s.orientation==\"b\" || s.orientation==\"c\"))\n\t\t\t\t\t\ty = s.plotSize.y - y;\t\n\t\t\t\t\tif (s.drawGrid)\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.moveTo(0, y);\n\t\t\t\t\t\tctx.lineTo(s.plotSize.x, y);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(i % s.labelFrequency.y) && s.labelFrequency.y > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tickLabel = s.range.x + i * s.unitPerTick.y;\n\t\t\t\t\t\tctx.fillText(s.labelPrecision.y == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.y), -5, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t//axis\n\t\t\tctx.strokeStyle = \"#000000\";\n\t\t\tctx.lineWidth = 1;\n\t\t\tctx.beginPath();\n\t\t\t\tvar axisOffset = new Point(\n\t\t\t\t(s.zeroBoundAxis ? Math.max(0, Math.min(s.plotSize.x, ((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : -s.domain.x) * s.pixelPerUnit.x)) : (s.orientation==\"c\"||s.orientation==\"d\") ? s.plotSize.x : 0),\n\t\t\t\t(s.zeroBoundAxis ? Math.min(s.plotSize.y, Math.max(0, ((s.orientation==\"b\"||s.orientation==\"c\") ? -s.range.x : s.range.y) * s.pixelPerUnit.y)) : (s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.plotSize.y));\n\t\t\t\tctx.moveTo(axisOffset.x, 0);\n\t\t\t\tctx.lineTo(axisOffset.x, s.plotSize.y);\n\t\t\t\tctx.moveTo(0, axisOffset.y);\n\t\t\t\tctx.lineTo(s.plotSize.x, axisOffset.y);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t//x axis label\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"bottom\";\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tctx.fillText(s.xAxis, s.plotSize.x * 0.5, s.plotSize.y + s.labelSize.y);\n\t\t\t\n\t\t\t//y axis label\n\t\t\tctx.translate(-s.labelSize.x,  s.plotSize.y * 0.5);\n\t\t\tctx.rotate(3 * Math.PI * 0.5);\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(s.yAxis, 0, 0);\n\t\t\tctx.rotate(-3 * Math.PI * 0.5);\n\t\t\tctx.translate(s.labelSize.x,  -(s.plotSize.y * 0.5));\n\t\t\t\n\t\t\t//coordinates\n\t\t\tif (s.drawCoords) //needs to be redone entirely\n\t\t\t{\n\t\t\t\tvar coordOffsetY = Math.max(ctx.measureText(s.domain.x).width, ctx.measureText(s.domain.y).width);\n\t\t\t\tvar coordOffsetX = coordOffsetY * 2 + ctx.measureText(\"y: \").width;\n\t\t\t\tctx.textAlign = \"left\";\n\t\t\t\tctx.textBaseline = \"bottom\";\n\t\t\t\tctx.fillText(\"x: \" + (isNaN(Math.round(this.mouse.move.x)) ? 0 : Math.round(this.mouse.move.x)), s.plotSize.x - coordOffsetX - 20, s.plotSize.y + s.labelSize.y);\n\t\t\t\tctx.fillText(\"y: \" + (isNaN(Math.round(this.mouse.move.y)) ? 0 : Math.round(this.mouse.move.y)), s.plotSize.x - coordOffsetY - 10, s.plotSize.y + s.labelSize.y);\n\t\t\t}\n\t\t\t\n\t\t\tctx.translate(-s.offset.x, -s.offset.y);\n\t\t}\n\t\t\n\t\treturn {\n\t\t\tset drawBorders(value) { debugBorders = value; },\n\t\t\tget drawBorders() { return debugBorders; },\n\t\t\tnewPlot: function(settings, name)\n\t\t\t{\n\t\t\t\tplot = new Plot(settings, ctx);\n\t\t\t\tplots.push(plot);\n\t\t\t\t\n\t\t\t\tif (typeof name !== \"undefined\")\n\t\t\t\t\tplotNames[name] = plots.length - 1;\n\t\t\t\t\n\t\t\t\trefitCanvas();\n\t\t\t\tdrawPlot(plot);\n\t\t\t\t\n\t\t\t\treturn plots.length - 1;\n\t\t\t},\n\t\t\tclearPlot: function(unclip)\n\t\t\t{\n\t\t\t\tunclip = typeof unclip !== \"undefined\" ? unclip : false;\n\t\t\t\t\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped && unclip)\n\t\t\t\t\tctx.restore();\n\t\t\t\t\n\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t},\n\t\t\teditPlot: function(plot, settings, reCalcLabels, redrawCanvas)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\t\n\t\t\t\tredrawCanvas = typeof redrawCanvas !== \"undefined\" ? redrawCanvas : false;\n\t\t\t\treCalcLabels = typeof reCalcLabels !== \"undefined\" ? reCalcLabels : false;\n\t\t\t\t\n\t\t\t\tif (plot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t\tctx.restore();\n\t\t\t\t\n\t\t\t\tif (redrawCanvas)\n\t\t\t\t{\n\t\t\t\t\tctx.clearRect(0,0, canvas.width, canvas.height);\n\t\t\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var key in settings)\n\t\t\t\t\tif (plot.settings.hasOwnProperty(key))\n\t\t\t\t\t\tplot.settings[key] = settings[key];\n\t\t\t\t\n\t\t\t\tif (reCalcLabels)\n\t\t\t\t\tplot.reCalculateLabels();\n\t\t\t\t\n\t\t\t\tdrawPlot(plot);\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t},\n\t\t\tselectPlot: function(plot, clear, clip)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tclear = typeof clear !== \"undefined\" ? clear : true;\n\t\t\t\tclip = typeof clip !== \"undefined\" ? clip : true;\n\t\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\t\n\t\t\t\tif (plot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t\tctx.restore();\n\t\t\t\tcurrentPlot = plot;\n\t\t\t\tif (clear)\n\t\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\t\n\t\t\t\tif (clip)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\t\t\t\telse if (clipped)\n\t\t\t\t\tclipped = false;\n\t\t\t},\n\t\n\t\n\t\t\tget ctx() { \n\t\t\t\treturn ctx; },\n\t\n\t\n\t\t\tget mouse()\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\treturn currentPlot.mouse;\n\t\t\t},\n\t\n\t\n\t\t\tget settings()\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\treturn currentPlot.settings;\n\t\t\t},\n\t\n\t\n\t\t\tpointOnPlot: function(p, plot)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && \n\t\t\t\t   (plot >= 0 && plot <= plots.length - 1)) {\n\t\t\t\t\t\tplot = plots[plot];\n\t\t\t\t}\n\t\t\t\telse if (typeof plot === \"string\" || \n\t\t\t\t\t\t plot instanceof String || \n\t\t\t\t\t\t Object.prototype.toString.call(plot) == \"[object String]\") {\n\t\n\t\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t\t}\n\t\t\t\telse if (plot.hasOwnProperty('constructor') && plot.constructor == String) {\n\t\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tplot = currentPlot;\n\t\t\t\t\n\t\t\t\treturn pointInBounds(p, plot);\n\t\t\t},\n\t\n\t\n\t\t\tplotToCanvas: function(p)\n\t\t\t{\n\t\t\t\tvar s = currentPlot.settings;\n\t\t\t\tvar x = (((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : 2 * p.x) - p.x - ((s.orientation==\"c\"||s.orientation==\"d\") ? 0 : s.domain.x)) * s.pixelPerUnit.x + s.offset.x;\n\t\t\t\tvar y = s.plotSize.y - ((((s.orientation==\"b\"||s.orientation==\"c\") ? s.range.y : 2 * p.y) - p.y - ((s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.range.x)) * s.pixelPerUnit.y) + s.offset.y;\n\t\t\t\treturn new Point(x, y);\n\t\t\t},\n\t\n\t\n\t\t\tplotPoint: function(p, r, fill)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tr = typeof r !== \"undefined\" ? r : 2;\n\t\t\t\tfill = typeof fill !== \"undefined\" ? fill : true;\n\t\t\t\t\n\t\t\t\tp = this.plotToCanvas(p);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n\t\t\t\tif (fill)\n\t\t\t\t\tctx.fill();\n\t\t\t\telse\n\t\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\tplotLine: function(p1, p2)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tp1 = this.plotToCanvas(p1);\n\t\t\t\tp2 = this.plotToCanvas(p2);\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\tplotSlope: function(p, slope)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar p1 = new Point(currentPlot.settings.domain.x, p.y - slope * (p.x - currentPlot.settings.domain.x));\n\t\t\t\tif (!pointInBounds(p1, currentPlot))\n\t\t\t\t{\n\t\t\t\t\tp1.y = p1.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\t\tp1.x = p.x - (p.y - p1.y)/slope;\n\t\t\t\t}\n\t\t\t\tvar p2 = new Point(currentPlot.settings.domain.y, p.y - slope * (p.x - currentPlot.settings.domain.y));\n\t\t\t\tif (!pointInBounds(p2, currentPlot))\n\t\t\t\t{\n\t\t\t\t\tp2.y = p2.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\t\tp2.x = p.x - (p.y - p2.y)/slope;\n\t\t\t\t}\n\t\t\t\tthis.plotLine(p1, p2);\n\t\t\t\t\n\t\t\t\treturn new Line(p1, p2, slope, new Point(p.x, p.y));\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Take an array of vertices and add them to the plot sequentially.\n\t\t\t * When all of them have been added, draw them on the canvas.\n\t\t\t * \n\t\t\t * @param  {Array.<Point>} points - an array that contains all of the \n\t\t\t * vertices of the polygon. They will be plotted in the order they are\n\t\t\t * listed in the array.\n\t\t\t * \n\t\t\t * @param  {[boolean]} closed - a boolean value that specifies whether \n\t\t\t * the vertices should be connected when the plot is rendered. By\n\t\t\t * default, the vertices will not be rendered.\n\t\t\t */\n\t\t\tplotPoly: function(points, closed)\n\t\t\t{\n\t\t\t\tvar length = Object.keys(points).length;\n\t\t\t\tif (currentPlot == undefined || length < 2)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tclosed = typeof closed !== \"undefined\" ? closed : false;\n\t\t\t\t\n\t\t\t\tif (typeof points == \"undefined\")\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\t\t\t\tfor (var i = 0; i < length - 1; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = this.plotToCanvas(points[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t}\n\t\t\t\t\tif (closed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = this.plotToCanvas(points[0]);\n\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t}\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Given a mathematical function, render it on a plot. This function\n\t\t\t * iterates from the start value to the end value. At each point, it\n\t\t\t * calculates the point at that value using the given function.\n\t\t\t * \n\t\t\t * @param  {Function} func - the function we want to plot on the graph.\n\t\t\t * It takes a numeric value as a parameter and returns a numeric value.\n\t\t\t * \n\t\t\t * @param  {[boolean]} xFunc - this specifies whether the function is\n\t\t\t * to be graphed along the x-axis or the y-axis. It's default value is\n\t\t\t * true.\n\t\t\t * \n\t\t\t * @param  {[number]} step - the value to increment by when calculating\n\t\t\t * function points. By default, it will increment by 1.\n\t\t\t * \n\t\t\t * @param  {[number]} start - this is the value that the function will\n\t\t\t * start calculating values at. By default, it will use the start value\n\t\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t\t * \n\t\t\t * @param  {[number]} end - this is the value that the function will\n\t\t\t * stop calculating values at. By default, it will use the end value\n\t\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t\t */\n\t\t\tplotFunction: function(func, xFunc, step, start, end)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\txFunc = typeof xFunc !== \"undefined\" ? xFunc : true;\n\t\t\t\tstep = typeof step !== \"undefined\" ? step : 1;\n\t\t\t\tstart = typeof start !== \"undefined\" ? start : (xFunc ? currentPlot.settings.domain.x : currentPlot.settings.range.x);\n\t\t\t\tend = typeof end !== \"undefined\" ? end : (xFunc ? currentPlot.settings.domain.y : currentPlot.settings.range.y);\n\t\n\t\t\t\tvar i = start, funcValue;\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * This loops iterates, adding the amount specified by timestep\n\t\t\t\t\t * value to the count each time. At each time. If the value exists,\n\t\t\t\t\t * it draws a line to the new location. It does this until the value\n\t\t\t\t\t * of the count is greater than or equal to the end value.\n\t\t\t\t\t */\n\t\t\t\t\twhile (i < end)\n\t\t\t\t\t{\n\t\t\t\t\t\tfuncValue = func(i);\n\t\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\t\tvar p = new Point(xFunc?i:funcValue, xFunc?funcValue:i);\n\t\t\t\t\t\t\tp = this.plotToCanvas(p);\t\t\n\t\t\t\t\t\t\tif (i != start) {\n\t\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti+= step;\n\t\t\t\t\t\tif (i > end) {\n\t\t\t\t\t\t\ti = end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * an edge case. In the event that start is greater than or\n\t\t\t\t\t * equal to end, plot that point\n\t\t\t\t\t */\n\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\t//points.push(new Point(xFunc?i:funcValue, xFunc?funcValue:i));\n\t\t\t\t\t}\n\t\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\t/** \n\t\t\t * If a plot is currently specified, draw the text at the specified\n\t\t\t * point on the plot.\n\t\t\t * @param  {string} text  - The text the user wants to write on the canvas\n\t\t\t * @param  {Point} point  - The point, in the plot's local coordinate\n\t\t\t * system, that the text will be rendered at.\n\t\t\t */\n\t\t\tplotText: function(text, point)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\tpoint = typeof point !== \"undefined\" ? point : new Point(currentPlot.settings.domain.x + (currentPlot.settings.domain.y - currentPlot.settings.domain.x) * 0.5, currentPlot.settings.range.x + (currentPlot.settings.range.y - currentPlot.settings.range.x) * 0.5);\n\t\t\t\tpoint = this.plotToCanvas(point);\n\t\t\t\tctx.fillText(text, point.x, point.y);\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Print the plot data of the pointObject as CSV. The function accepts\n\t\t\t * a PointObject, retrives its points and parses the specified fields\n\t\t\t * as a CSV file. If no fields are specified, the function will print\n\t\t\t * all of them.\n\t\t\t *\n\t\t\t * @param  {PointObject} pointObject - the object from which plotter\n\t\t\t * retrieves the points.\n\t\t\t * @param  {[Array]} fields - an array of the fields to display\n\t\t\t */\n\t\t\tprintPlotData: function(pointObject, fields) {\n\t\t\t\tvar csv = \"\";\n\t\t\t\tvar points = pointObject.getPoints();\n\t\t\t\tvar header = fields ? fields : Object.keys(points[0]);\n\t\t\t\t\n\t\t\t\tvar point = {};\n\t\t\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tif (i === 0) {\t\n\t\t\t\t\t\tfor(var j = 0; j < header.length; j++) {\n\t\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcsv += header[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tfor (var j = 0; j < header.length; j++) {\n\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += point[header[j]];\n\t\t\t\t\t}\n\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t}\n\t\t\t\twindow.open(\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv));;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmodule.exports = createPlotter;\n\t// function createPlotter() {\n\t// \treturn Plotter.apply(this, arguments;\n\t// }\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plotter.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4c93c2d5cf8c4e42ee36\n **/","module.exports.Point = require('./point');\nmodule.exports.Line = require('./line');\nmodule.exports.Plot = require('./plot');\nmodule.exports = require('./plotter');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","/**\n * A generic object for holding a point\n * @param {number} px - the x coordinate of the point\n * @param {number} py - the y coordinate of the point\n */\nfunction Point(px, py) {\n\tthis.x = px; \n\tthis.y = py;\n}\n\nmodule.exports = Point;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/point.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * A generic object for holding a line.\n * @param {Point} pa - the first point on the line (used for calculating a line based on two points)\n * @param {Point} pb - the second point on the line (used for calculating a line based on two points)\n * @param {number} s - the slope of the line (used for calculating a line based on point-slope)\n * @param {Point} p - the point on the line (used for calculating a line based on point-slope)\n */\nfunction Line(pa, pb, s, p) {\n\tthis.a = pa; \n\tthis.b = pb; \n\tthis.point = p; \n\tthis.slope = s;\n} \n\nmodule.exports = Line;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/line.js\n ** module id = 2\n ** module chunks = 0\n **/","var Point = require('./point');\n\n/**\n * Plots are what Points (and objects that consist of Points) are rendered on.\n * Plots describe the context in which Points are drawn, holding information\n * such as labels and a local coordinate system. Plotter uses this information\n * when plotting points and other objects.\n */\nfunction Plot()\n{\n\tvar ctx = arguments[1];\t\t\t\t\t\t\t// the context in which the \n\tvar settings = arguments[0];\n\t\n\tvar offsetVar = new Point(0, 0);\n\tvar domainVar = new Point(-10, 10);\n\tvar rangeVar = new Point(-10, 10);\n\tvar plotSizeVar = new Point(0, 0);\n\tvar pixelPerUnitVar = new Point(10, 10);\n\tvar unitPerTickVar = new Point(1, 1);\n\tvar labelFrequencyVar = new Point(2, 2);\n\tvar labelSizeVar = new Point(0, 0);\n\tvar labelBleedVar = new Point(0, 0);\n\tvar labelPrecisionVar = new Point(-1, -1);\n\t\n\n\t/**\n\t * Plot is a module. All variables enclosed are inaccesible from the \n\t * outside. self is returned to expose some of these variables\n\t * @type {Object}\n\t */\n\tvar self = {\t\n\n\n\t\t/**\n\t\t * @property {object} settings - a collection of settings that affect\n\t\t * how the plot is rendered\n\t\t * \n\t\t * @property {Point} settings.offset - by default, a graph is rendered \n\t\t * in the upper left corner of the canvas. This allows you to \n\t\t * reposition the plot relative to this point.\n\t\t *\n\t\t * @property {Point} settings.domain - the points along the x-axis that\n\t\t * the plot will display\n\t\t *\n\t\t * @property {Point} settings.range - the points along the y-axis that \n\t\t * the plot will display\n\t\t *\n\t\t * @property {Point} settins.pixelPerUnit - The number of pixels that \n\t\t * each unit of the plot will take up\n\t\t *\n\t\t * @property {Point} settings.plotSize - (readonly) The size of the \n\t\t * plot in pixels. This value is calculated by multiplying the pixels \n\t\t * per unit by the number of units in the graph (domain end - domain \n\t\t * start and range end - range start)\n\t\t *\n\t\t * @property {Point} settings.unitPerTick - A tick is wherever a line is drawn\n\t\t * on the plot. This controls how many units must pass before a tick is\n\t\t * drawn\n\t\t *\n\t\t * @property {Point} settings.gridSize - (readonly) The size of each block of \n\t\t * ticks on the plot. Calculated by multiplying the pixelPerUnit by the\n\t\t * unitPerTick\n\t\t *\n\t\t * @property {Point} settings.labelFrequency - This is the rate at which labels\n\t\t * are drawn on the ticks. It will default to a label for every tick\n\t\t *\n\t\t * @property {Point} settings.labelSize - (readonly) The size of the \n\t\t * label, where x is width and y is height, as calculated by \n\t\t * calculateLabelSize()\n\t\t *\n\t\t * @property {Point} settings.labelBleed - (readonly)\n\t\t *\n\t\t * @property {Point} settings.labelPrecision - This is a point that \n\t\t * determines how many decimals trail after the \".\" character. Values\n\t\t * less than 0 disable this feature.\n\t\t *\n\t\t * @property {string} settings.xAxis - the label for the x axis\n\t\t *\n\t\t * @property {string} settings.yAxis - the label for the y axis\n\t\t * \n\t\t * @property {boolean} settings.zeroBoundAxis - determines whether a \n\t\t * thick black line is drawn around the 0 axis. If false, the thick\n\t\t * black line will be drawn around the edges of the graph.\n\t\t * \n\t\t * @property {boolean} settings.drawGrid - determines whether the \n\t\t *\n\t\t * @property {boolean} settings.drawCoords - If true, the mouse\n\t\t * coordinates will be rendered. CURRENTLY NOT WORKING.\n\t\t * \n\t\t * @property {string} settings.orientation - determines where the\n\t\t * origin of the graph is rendered. It starts at the bottom left and\n\t\t * goes counterclockwise. \"a\" is the bottom left, \"b\" is the top left,\n\t\t * \"c\" is the top right, \"d\" is the bottom right.\n\t\t */\n\t\tsettings:\n\t\t{\n\t\t\tset offset(value) \n\t\t\t{\n\t\t\t\toffsetVar.x = value.x;\n\t\t\t\toffsetVar.y = value.y;\n\t\t\t},\n\t\t\tget offset() { return new Point(offsetVar.x + 75, offsetVar.y + 20); },\n\t\t\tset domain(value)\n\t\t\t{\n\t\t\t\tdomainVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\tdomainVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t},\n\t\t\tget domain() { return new Point(domainVar.x, domainVar.y); },\n\t\t\tset range(value)\n\t\t\t{\n\t\t\t\trangeVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\trangeVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t},\n\t\t\tget range() { return new Point(rangeVar.x, rangeVar.y); },\n\t\t\tset pixelPerUnit(value)\n\t\t\t{\n\t\t\t\tpixelPerUnitVar.x = value.x != 0 ? value.x : pixelPerUnitVar.x;\n\t\t\t\tpixelPerUnitVar.y = value.y != 0 ? value.y : pixelPerUnitVar.y;\n\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t},\n\t\t\tget pixelPerUnit() { return new Point(pixelPerUnitVar.x, pixelPerUnitVar.y); },\n\t\t\tget plotSize() { return new Point(plotSizeVar.x, plotSizeVar.y); },\n\t\t\tset unitPerTick(value)\n\t\t\t{\n\t\t\t\tunitPerTickVar.x = value.x != 0 ? value.x : unitPerTickVar.x;\n\t\t\t\tunitPerTickVar.y = value.y != 0 ? value.y : unitPerTickVar.y;\n\t\t\t},\n\t\t\tget unitPerTick() { return new Point(unitPerTickVar.x, unitPerTickVar.y); },\n\t\t\tget gridSize()\n\t\t\t{ return new Point(this.unitPerTick.x * this.pixelPerUnit.x, this.unitPerTick.y * this.pixelPerUnit.y); },\n\t\t\tset labelFrequency(value)\n\t\t\t{\n\t\t\t\tlabelFrequencyVar.x = value.x >= 0 ? value.x : 0;\n\t\t\t\tlabelFrequencyVar.y = value.y >= 0 ? value.y : 0;\n\t\t\t},\n\t\t\tget labelFrequency() { return new Point(labelFrequencyVar.x, labelFrequencyVar.y); },\n\t\t\tget labelSize() { return new Point(labelSizeVar.x, labelSizeVar.y); },\n\t\t\tget labelBleed() { return new Point(labelBleedVar.x, labelBleedVar.y); },\n\t\t\tset labelPrecision(value)\n\t\t\t{\n\t\t\t\tlabelPrecisionVar.x = value.x >= 0 ? Math.min(20, Math.max(0, value.x)) : -1;\n\t\t\t\tlabelPrecisionVar.y = value.y >= 0 ? Math.min(20, Math.max(0, value.y)) : -1;\n\t\t\t},\n\t\t\tget labelPrecision() { return new Point(labelPrecisionVar.x, labelPrecisionVar.y); },\n\t\t\txAxis: \"xAxis\",\n\t\t\tyAxis: \"yAxis\",\n\t\t\tzeroBoundAxis: true,\n\t\t\tdrawGrid: true,\n\t\t\tdrawCoords: false,\n\t\t\torientation: \"a\"\n\t\t},\n\n\n\t\t/**\n\t\t * @property {object} mouse - a collection of settings related to the \n\t\t * mouse in relation to the plot.\n\t\t *\n\t\t * @property {Point} mouse.down - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.move - The point in the plot's local\n\t\t * coordinates where the mouse has moved to\t \n\t\t * \n\t\t * @property {Point} mouse.up - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.isDown - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.isUp - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t */\n\t\tmouse:\n\t\t{\n\t\t\tdown: new Point(),\n\t\t\tmove: new Point(),\n\t\t\tup: new Point(),\n\t\t\tisDown: false,\n\t\t\tisUp: true\n\t\t},\n\n\n\t\t/**\n\t\t * Recalculate the size of the labels and the label bleed.\n\t\t */\n\t\treCalculateLabels: function() { \n\t\t\tcalculateLabelSize(); \n\t\t\tcalculateLabelBleed(); \n\t\t}\n\t}\n\t\n\t/**  \n\t * This initializes the Plot, merging the default settings object with the\n\t * object that was passed to the function as an argument. It then calculates\n\t * the size of the plot and the labels.\n\t */\n\tfor (var key in settings)\n\t\tif (self.settings.hasOwnProperty(key))\n\t\t\tself.settings[key] = settings[key];\n\t\n\tplotSizeVar.x = self.settings.pixelPerUnit.x * (self.settings.domain.y - self.settings.domain.x);\n\tplotSizeVar.y = self.settings.pixelPerUnit.y * (self.settings.range.y - self.settings.range.x);\n\t\n\tcalculateLabelSize();\n\tcalculateLabelBleed();\n\t\n\n\t/**\n\t * This function calculates padding that labels add to the graph. This is the\n\t * entire block of labels on each axis. It determines what the maximum \n\t * length of the value labels would be on each axis and then adds padding to \n\t * encompass the label of the axis.\n\t */\n\tfunction calculateLabelSize()\n\t{\n\t\tvar x = 0;\n\t\tvar y = 0;\n\t\tvar s = self.settings;\n\t\t\n\t\tctx.font = \"24px Helvetica\";\n\t\tvar labelPadding = ctx.measureText(\"M.\").width;\n\t\t\n\t\tif (s.labelFrequency.y != 0) {\n\t\t\tx += Math.max(ctx.measureText(s.range.x).width, ctx.measureText(s.range.x + Math.floor(s.plotSize.y / s.gridSize.y) * s.unitPerTick.y).width);\n\t\t}\n\t\telse {\n\t\t\tx += 6;\n\t\t}\n\t\tif (s.yAxis != \"\") {\n\t\t\tx += labelPadding;\n\t\t}\n\n\t\tif (s.labelFrequency.x != 0) {\n\t\t\ty += labelPadding;\n\t\t}\n\t\telse {\n\t\t\ty += 6;\n\t\t}\n\t\tif (s.xAxis != \"\") {\n\t\t\ty += labelPadding;\n\t\t}\n\t\tif (s.yAxis != \"\")\n\t\t{\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tvar yBleed = ctx.measureText(s.yAxis).width * 0.5 - s.plotSize.y * 0.5;\n\t\t\ty = yBleed > y ? yBleed : y;\n\t\t}\n\t\t\n\t\tlabelSizeVar.x = x;\n\t\tlabelSizeVar.y = y;\n\t}\n\t\n\n\t/**\n\t * This function calculates the \"bleed\" of the labels. Essentially, if a \n\t * label value overflows, this provides a cutoff after which it will stop\n\t * rendering the text.\n\t * @return {[type]} [description]\n\t */\n\tfunction calculateLabelBleed()\n\t{\n\t\tvar s = self.settings;\n\t\tvar x = 0;\n\t\tvar y = s.labelFrequency.y != 0 ? -8 : 0;\n\t\t\n\t\tctx.font = \"16px Helvetica\";\n\t\t\n\t\tif (s.labelFrequency.x != 0) {\n\t\t\tx =  Math.max(s.offset.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.gridSize.x + ctx.measureText(s.domain.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.unitPerTick.x).width * 0.5 - (s.offset.x + s.plotSize.x), 0);\n\t\t}\n\t\t\n\t\tctx.font = \"24px Helvetica\";\n\t\t\n\t\tif (s.xAxis != \"\")\n\t\t{ \n\t\t\tvar axisBleed = Math.max(((s.domain.y - s.domain.x) * s.pixelPerUnit.x * 0.5 + ctx.measureText(s.xAxis).width * 0.5) - ((s.domain.y - s.domain.x) * s.pixelPerUnit.x), 0);\n\t\t\tx = x > axisBleed ? x : axisBleed;\n\t\t}\n\t\t\n\t\tif (s.yAxis != \"\")\n\t\t{\n\t\t\tvar yLabelBleed = s.plotSize.y * 0.5 - ctx.measureText(s.yAxis).width * 0.5;\n\t\t\ty = yLabelBleed < y ? yLabelBleed : y;\n\t\t}\n\t\t\n\t\tlabelBleedVar.x = x;\n\t\tlabelBleedVar.y = y;\n\t}\n\t\n\treturn self;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plot.js\n ** module id = 3\n ** module chunks = 0\n **/","var Point = require('./point');\nvar Plot = require('./plot');\nvar Line = require('./line');\n\n/**\n * Creates a Plotter object. Given a HTML Canvas Element, this function creates\n * a series of functions for interacting with it. It also attaches some of\n * these functions to event listeners for mouse and touch events.\n *\n * @param {HTMLCanvasElement} canvas - The Canvas element that plots will be\n * drawn on.\n *\n * @param {Point} padding - a Point that describs how much padding\n * to apply to the canvas element before rendering elements.\n * \n * @return {Plotter} - An object that collects properties and methods for \n * interacting with the canvas element passed to the function.\n */\nfunction createPlotter()\n{\n\tvar canvas, ctx;\n\tvar plots = [];\n\tvar plotNames = {};\n\tvar currentPlot, clipped = false;\n\tvar debugBorders = false;\n\tvar padding = typeof arguments[1] !== \"undefined\" ? arguments[1] : new Point(0, 0);\n\t\n\tcanvas = arguments[0];\n\tctx = canvas.getContext(\"2d\");\n\t\t\n\tcanvas.addEventListener(\"mousedown\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"mousemove\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"mouseup\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"touchstart\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchmove\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchend\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchcancel\", function(e){updateTouch(e);}, false);\n\t\n\tfunction pageToPlot(p, plot)\n\t{\n\t\tvar s = plot.settings;\n\t\tvar x = (p.x - canvas.offsetLeft - s.offset.x) / s.pixelPerUnit.x + s.domain.x;\n\t\tvar y = (canvas.height - (p.y - canvas.offsetTop) - (canvas.height - (s.offset.y + s.plotSize.y))) / s.pixelPerUnit.y + s.range.x;\n\t\treturn new Point(x, y);\n\t}\n\t\n\tfunction pointInBounds(p, plot)\n\t{\n\t\tvar s = plot.settings;\n\t\treturn (p.x >= s.domain.x && p.x <= s.domain.y && p.y >= s.range.x && p.y <= s.range.y)\n\t}\n\t\n\tfunction findPlotUnderPoint(p)\n\t{\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\tif (pointInBounds(pageToPlot(p, plots[i]), plots[i]))\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n\t\n\tfunction updateMouse(e)\n\t{\n\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\tif (plot == -1)\n\t\t\treturn;\n\t\tplot = plots[plot];\n\t\t\n\t\tvar p = pageToPlot(new Point(e.pageX, e.pageY), plot);\n\t\tvar type = e.type.replace(\"mouse\", '');\n\t\t\n\t\tif ((type == \"down\" || type == \"move\") && (!(e.buttons & 1) && e.button != 0))\n\t\t\treturn;\n\t\t\n\t\tplot.mouse[type].x = p.x;\n\t\tplot.mouse[type].y = p.y;\n\t\tif (type == \"down\")\n\t\t{\n\t\t\tplot.mouse.isDown = true;\n\t\t\tplot.mouse.isUp = false;\n\t\t}\n\t\telse if (type == \"up\")\n\t\t{\n\t\t\tplot.mouse.isDown = false;\n\t\t\tplot.mouse.isUp = true;\n\t\t}\n\t}\n\t\n\tfunction updateTouch(e)\n\t{\t\n\t\tvar type = e.type.replace(\"touch\",'');\n\t\t\n\t\tfor(var i = 0; i < e.changedTouches.length; i++)\n\t\t{\n\t\t\tvar touchID, event;\n\t\t\t\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase \"start\":\n\t\t\t\t\tevent = new MouseEvent(\"mousedown\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tcase \"move\":\n\t\t\t\t\tevent = new MouseEvent(\"mousemove\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tcase \"cancel\":\n\t\t\t\tcase \"end\":\n\t\t\t\t\tevent = new MouseEvent(\"mouseup\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcanvas.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tif (e.touches.length > 0)\n\t\t{\n\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\tif (plot != -1)\n\t\t\t{\n\t\t\t\tplots[plot].mouse.isDown = true;\n\t\t\t\tplots[plot].mouse.isUp = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (e.touches.length == 1 && type == \"move\")\n\t\t\te.preventDefault();\n\t}\n\t\n\tfunction refitCanvas()\n\t{\n\t\tif (plots.length == 0)\n\t\t\treturn;\n\t\t\n\t\tif (clipped)\n\t\t{\n\t\t\tctx.restore();\n\t\t\tclipped = false;\n\t\t}\n\t\t\n\t\tvar size = new Point(0, 0);\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t{\n\t\t\tvar s = plots[i].settings;\n\t\t\tsize.x = Math.max(size.x, s.offset.x + s.plotSize.x + s.labelBleed.x);\n\t\t\tsize.y = Math.max(size.y, s.offset.y + s.plotSize.y + s.labelSize.y);\n\t\t}\t\t\t\n\t\tcanvas.width = size.x + padding.x + 10;\n\t\tcanvas.height = size.y + padding.y + 10;\n\t\t\n\t\tctx.strokeStyle = \"#0000FF\";\n\t\tctx.lineWidth = 2;\n\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\tdrawPlot(plots[i]);\n\t}\n\t\n\t/**\n\t * Renders the specified plot on the canvas. This function takes a Plot\n\t * object and then uses its settings to draw it on the canvas.\n\t * @param  {Plot} plot - the Plot object we want to render on the canvas\n\t */\n\tfunction drawPlot(plot)\n\t{\n\t\tvar s = plot.settings;\n\t\t\n\t\tctx.translate(s.offset.x, s.offset.y);\n\t\tctx.clearRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\tif (debugBorders)\n\t\t{\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t}\t\n\t\tctx.lineWidth = 2;\n\t\t\n\t\t//plot\n\t\tctx.fillStyle = \"#F8F8F8\";\n\t\tctx.fillRect(0, 0, s.plotSize.x, s.plotSize.y);\n\t\tctx.fillStyle = \"#000000\";\n\t\tctx.strokeStyle = \"#E0E0E0\";\n\t\tctx.font = \"16px Helvetica\";\n\t\tctx.textAlign = \"center\";\n\t\tctx.textBaseline = \"top\";\n\t\tctx.beginPath();\n\t\t\tfor( var i = 0; i <= s.plotSize.x / s.gridSize.x; i++)\n\t\t\t{\n\t\t\t\tvar x = i * s.gridSize.x;\n\t\t\t\tif (s.orientation==\"c\" || s.orientation==\"d\")\n\t\t\t\t\tx = s.plotSize.x - x;\n\t\t\t\t\n\t\t\t\tif (s.drawGrid)\n\t\t\t\t{\n\t\t\t\t\tctx.moveTo(x, s.plotSize.y);\n\t\t\t\t\tctx.lineTo(x, 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!(i % s.labelFrequency.x) && s.labelFrequency.x > 0)\n\t\t\t\t{\n\t\t\t\t\tvar tickLabel = s.domain.x + i * s.unitPerTick.x;\n\t\t\t\t\tctx.fillText( s.labelPrecision.x == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.x), x, s.plotSize.y + 5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.textAlign = \"right\";\n\t\t\tctx.textBaseline = \"middle\";\n\t\t\tfor( var i = 0; i <= s.plotSize.y / s.gridSize.y; i++)\n\t\t\t{\n\t\t\t\tvar y = i * s.gridSize.y;\n\t\t\t\tif (!(s.orientation==\"b\" || s.orientation==\"c\"))\n\t\t\t\t\ty = s.plotSize.y - y;\t\n\t\t\t\tif (s.drawGrid)\n\t\t\t\t{\n\t\t\t\t\tctx.moveTo(0, y);\n\t\t\t\t\tctx.lineTo(s.plotSize.x, y);\n\t\t\t\t}\n\t\t\t\tif (!(i % s.labelFrequency.y) && s.labelFrequency.y > 0)\n\t\t\t\t{\n\t\t\t\t\tvar tickLabel = s.range.x + i * s.unitPerTick.y;\n\t\t\t\t\tctx.fillText(s.labelPrecision.y == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.y), -5, y);\n\t\t\t\t}\n\t\t\t}\n\t\tctx.stroke();\n\t\t\n\t\t//axis\n\t\tctx.strokeStyle = \"#000000\";\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\t\tvar axisOffset = new Point(\n\t\t\t(s.zeroBoundAxis ? Math.max(0, Math.min(s.plotSize.x, ((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : -s.domain.x) * s.pixelPerUnit.x)) : (s.orientation==\"c\"||s.orientation==\"d\") ? s.plotSize.x : 0),\n\t\t\t(s.zeroBoundAxis ? Math.min(s.plotSize.y, Math.max(0, ((s.orientation==\"b\"||s.orientation==\"c\") ? -s.range.x : s.range.y) * s.pixelPerUnit.y)) : (s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.plotSize.y));\n\t\t\tctx.moveTo(axisOffset.x, 0);\n\t\t\tctx.lineTo(axisOffset.x, s.plotSize.y);\n\t\t\tctx.moveTo(0, axisOffset.y);\n\t\t\tctx.lineTo(s.plotSize.x, axisOffset.y);\n\t\tctx.stroke();\n\t\t\n\t\t//x axis label\n\t\tctx.textAlign = \"center\";\n\t\tctx.textBaseline = \"bottom\";\n\t\tctx.font = \"24px Helvetica\";\n\t\tctx.fillText(s.xAxis, s.plotSize.x * 0.5, s.plotSize.y + s.labelSize.y);\n\t\t\n\t\t//y axis label\n\t\tctx.translate(-s.labelSize.x,  s.plotSize.y * 0.5);\n\t\tctx.rotate(3 * Math.PI * 0.5);\n\t\tctx.textBaseline = \"top\";\n\t\tctx.fillText(s.yAxis, 0, 0);\n\t\tctx.rotate(-3 * Math.PI * 0.5);\n\t\tctx.translate(s.labelSize.x,  -(s.plotSize.y * 0.5));\n\t\t\n\t\t//coordinates\n\t\tif (s.drawCoords) //needs to be redone entirely\n\t\t{\n\t\t\tvar coordOffsetY = Math.max(ctx.measureText(s.domain.x).width, ctx.measureText(s.domain.y).width);\n\t\t\tvar coordOffsetX = coordOffsetY * 2 + ctx.measureText(\"y: \").width;\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.textBaseline = \"bottom\";\n\t\t\tctx.fillText(\"x: \" + (isNaN(Math.round(this.mouse.move.x)) ? 0 : Math.round(this.mouse.move.x)), s.plotSize.x - coordOffsetX - 20, s.plotSize.y + s.labelSize.y);\n\t\t\tctx.fillText(\"y: \" + (isNaN(Math.round(this.mouse.move.y)) ? 0 : Math.round(this.mouse.move.y)), s.plotSize.x - coordOffsetY - 10, s.plotSize.y + s.labelSize.y);\n\t\t}\n\t\t\n\t\tctx.translate(-s.offset.x, -s.offset.y);\n\t}\n\t\n\treturn {\n\t\tset drawBorders(value) { debugBorders = value; },\n\t\tget drawBorders() { return debugBorders; },\n\t\tnewPlot: function(settings, name)\n\t\t{\n\t\t\tplot = new Plot(settings, ctx);\n\t\t\tplots.push(plot);\n\t\t\t\n\t\t\tif (typeof name !== \"undefined\")\n\t\t\t\tplotNames[name] = plots.length - 1;\n\t\t\t\n\t\t\trefitCanvas();\n\t\t\tdrawPlot(plot);\n\t\t\t\n\t\t\treturn plots.length - 1;\n\t\t},\n\t\tclearPlot: function(unclip)\n\t\t{\n\t\t\tunclip = typeof unclip !== \"undefined\" ? unclip : false;\n\t\t\t\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped && unclip)\n\t\t\t\tctx.restore();\n\t\t\t\n\t\t\tdrawPlot(currentPlot);\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t}\n\t\t},\n\t\teditPlot: function(plot, settings, reCalcLabels, redrawCanvas)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\n\t\t\tredrawCanvas = typeof redrawCanvas !== \"undefined\" ? redrawCanvas : false;\n\t\t\treCalcLabels = typeof reCalcLabels !== \"undefined\" ? reCalcLabels : false;\n\t\t\t\n\t\t\tif (plot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t\tctx.restore();\n\t\t\t\n\t\t\tif (redrawCanvas)\n\t\t\t{\n\t\t\t\tctx.clearRect(0,0, canvas.width, canvas.height);\n\t\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\t\tctx.lineWidth = 2;\n\t\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var key in settings)\n\t\t\t\tif (plot.settings.hasOwnProperty(key))\n\t\t\t\t\tplot.settings[key] = settings[key];\n\t\t\t\n\t\t\tif (reCalcLabels)\n\t\t\t\tplot.reCalculateLabels();\n\t\t\t\n\t\t\tdrawPlot(plot);\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t}\n\t\t},\n\t\tselectPlot: function(plot, clear, clip)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tclear = typeof clear !== \"undefined\" ? clear : true;\n\t\t\tclip = typeof clip !== \"undefined\" ? clip : true;\n\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\n\t\t\tif (plot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t\tctx.restore();\n\t\t\tcurrentPlot = plot;\n\t\t\tif (clear)\n\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t\tclipped = true;\n\t\t\t}\n\t\t\telse if (clipped)\n\t\t\t\tclipped = false;\n\t\t},\n\n\n\t\tget ctx() { \n\t\t\treturn ctx; },\n\n\n\t\tget mouse()\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\treturn currentPlot.mouse;\n\t\t},\n\n\n\t\tget settings()\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\treturn currentPlot.settings;\n\t\t},\n\n\n\t\tpointOnPlot: function(p, plot)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && \n\t\t\t   (plot >= 0 && plot <= plots.length - 1)) {\n\t\t\t\t\tplot = plots[plot];\n\t\t\t}\n\t\t\telse if (typeof plot === \"string\" || \n\t\t\t\t\t plot instanceof String || \n\t\t\t\t\t Object.prototype.toString.call(plot) == \"[object String]\") {\n\n\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t}\n\t\t\telse if (plot.hasOwnProperty('constructor') && plot.constructor == String) {\n\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t}\n\t\t\telse\n\t\t\t\tplot = currentPlot;\n\t\t\t\n\t\t\treturn pointInBounds(p, plot);\n\t\t},\n\n\n\t\tplotToCanvas: function(p)\n\t\t{\n\t\t\tvar s = currentPlot.settings;\n\t\t\tvar x = (((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : 2 * p.x) - p.x - ((s.orientation==\"c\"||s.orientation==\"d\") ? 0 : s.domain.x)) * s.pixelPerUnit.x + s.offset.x;\n\t\t\tvar y = s.plotSize.y - ((((s.orientation==\"b\"||s.orientation==\"c\") ? s.range.y : 2 * p.y) - p.y - ((s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.range.x)) * s.pixelPerUnit.y) + s.offset.y;\n\t\t\treturn new Point(x, y);\n\t\t},\n\n\n\t\tplotPoint: function(p, r, fill)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tr = typeof r !== \"undefined\" ? r : 2;\n\t\t\tfill = typeof fill !== \"undefined\" ? fill : true;\n\t\t\t\n\t\t\tp = this.plotToCanvas(p);\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n\t\t\tif (fill)\n\t\t\t\tctx.fill();\n\t\t\telse\n\t\t\t\tctx.stroke();\n\t\t},\n\n\n\t\tplotLine: function(p1, p2)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tp1 = this.plotToCanvas(p1);\n\t\t\tp2 = this.plotToCanvas(p2);\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\tplotSlope: function(p, slope)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tvar p1 = new Point(currentPlot.settings.domain.x, p.y - slope * (p.x - currentPlot.settings.domain.x));\n\t\t\tif (!pointInBounds(p1, currentPlot))\n\t\t\t{\n\t\t\t\tp1.y = p1.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\tp1.x = p.x - (p.y - p1.y)/slope;\n\t\t\t}\n\t\t\tvar p2 = new Point(currentPlot.settings.domain.y, p.y - slope * (p.x - currentPlot.settings.domain.y));\n\t\t\tif (!pointInBounds(p2, currentPlot))\n\t\t\t{\n\t\t\t\tp2.y = p2.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\tp2.x = p.x - (p.y - p2.y)/slope;\n\t\t\t}\n\t\t\tthis.plotLine(p1, p2);\n\t\t\t\n\t\t\treturn new Line(p1, p2, slope, new Point(p.x, p.y));\n\t\t},\n\n\n\t\t/**\n\t\t * Take an array of vertices and add them to the plot sequentially.\n\t\t * When all of them have been added, draw them on the canvas.\n\t\t * \n\t\t * @param  {Array.<Point>} points - an array that contains all of the \n\t\t * vertices of the polygon. They will be plotted in the order they are\n\t\t * listed in the array.\n\t\t * \n\t\t * @param  {[boolean]} closed - a boolean value that specifies whether \n\t\t * the vertices should be connected when the plot is rendered. By\n\t\t * default, the vertices will not be rendered.\n\t\t */\n\t\tplotPoly: function(points, closed)\n\t\t{\n\t\t\tvar length = Object.keys(points).length;\n\t\t\tif (currentPlot == undefined || length < 2)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tclosed = typeof closed !== \"undefined\" ? closed : false;\n\t\t\t\n\t\t\tif (typeof points == \"undefined\")\n\t\t\t\treturn;\n\t\t\t\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < length - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tvar p = this.plotToCanvas(points[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t}\n\t\t\t\tif (closed)\n\t\t\t\t{\n\t\t\t\t\tvar p = this.plotToCanvas(points[0]);\n\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t}\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\t/**\n\t\t * Given a mathematical function, render it on a plot. This function\n\t\t * iterates from the start value to the end value. At each point, it\n\t\t * calculates the point at that value using the given function.\n\t\t * \n\t\t * @param  {Function} func - the function we want to plot on the graph.\n\t\t * It takes a numeric value as a parameter and returns a numeric value.\n\t\t * \n\t\t * @param  {[boolean]} xFunc - this specifies whether the function is\n\t\t * to be graphed along the x-axis or the y-axis. It's default value is\n\t\t * true.\n\t\t * \n\t\t * @param  {[number]} step - the value to increment by when calculating\n\t\t * function points. By default, it will increment by 1.\n\t\t * \n\t\t * @param  {[number]} start - this is the value that the function will\n\t\t * start calculating values at. By default, it will use the start value\n\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t * \n\t\t * @param  {[number]} end - this is the value that the function will\n\t\t * stop calculating values at. By default, it will use the end value\n\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t */\n\t\tplotFunction: function(func, xFunc, step, start, end)\n\t\t{\n\t\t\tif (currentPlot == undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txFunc = typeof xFunc !== \"undefined\" ? xFunc : true;\n\t\t\tstep = typeof step !== \"undefined\" ? step : 1;\n\t\t\tstart = typeof start !== \"undefined\" ? start : (xFunc ? currentPlot.settings.domain.x : currentPlot.settings.range.x);\n\t\t\tend = typeof end !== \"undefined\" ? end : (xFunc ? currentPlot.settings.domain.y : currentPlot.settings.range.y);\n\n\t\t\tvar i = start, funcValue;\n\t\t\tvar points = [];\n\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\n\t\t\t\t/*\n\t\t\t\t * This loops iterates, adding the amount specified by timestep\n\t\t\t\t * value to the count each time. At each time. If the value exists,\n\t\t\t\t * it draws a line to the new location. It does this until the value\n\t\t\t\t * of the count is greater than or equal to the end value.\n\t\t\t\t */\n\t\t\t\twhile (i < end)\n\t\t\t\t{\n\t\t\t\t\tfuncValue = func(i);\n\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\tvar p = new Point(xFunc?i:funcValue, xFunc?funcValue:i);\n\t\t\t\t\t\tp = this.plotToCanvas(p);\t\t\n\t\t\t\t\t\tif (i != start) {\n\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+= step;\n\t\t\t\t\tif (i > end) {\n\t\t\t\t\t\ti = end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * an edge case. In the event that start is greater than or\n\t\t\t\t * equal to end, plot that point\n\t\t\t\t */\n\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t//points.push(new Point(xFunc?i:funcValue, xFunc?funcValue:i));\n\t\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\t/** \n\t\t * If a plot is currently specified, draw the text at the specified\n\t\t * point on the plot.\n\t\t * @param  {string} text  - The text the user wants to write on the canvas\n\t\t * @param  {Point} point  - The point, in the plot's local coordinate\n\t\t * system, that the text will be rendered at.\n\t\t */\n\t\tplotText: function(text, point)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\tpoint = typeof point !== \"undefined\" ? point : new Point(currentPlot.settings.domain.x + (currentPlot.settings.domain.y - currentPlot.settings.domain.x) * 0.5, currentPlot.settings.range.x + (currentPlot.settings.range.y - currentPlot.settings.range.x) * 0.5);\n\t\t\tpoint = this.plotToCanvas(point);\n\t\t\tctx.fillText(text, point.x, point.y);\n\t\t},\n\n\n\t\t/**\n\t\t * Print the plot data of the pointObject as CSV. The function accepts\n\t\t * a PointObject, retrives its points and parses the specified fields\n\t\t * as a CSV file. If no fields are specified, the function will print\n\t\t * all of them.\n\t\t *\n\t\t * @param  {PointObject} pointObject - the object from which plotter\n\t\t * retrieves the points.\n\t\t * @param  {[Array]} fields - an array of the fields to display\n\t\t */\n\t\tprintPlotData: function(pointObject, fields) {\n\t\t\tvar csv = \"\";\n\t\t\tvar points = pointObject.getPoints();\n\t\t\tvar header = fields ? fields : Object.keys(points[0]);\n\t\t\t\n\t\t\tvar point = {};\n\t\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\t\tpoint = points[i];\n\t\t\t\tif (i === 0) {\t\n\t\t\t\t\tfor(var j = 0; j < header.length; j++) {\n\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += header[j];\n\t\t\t\t\t}\n\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < header.length; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t}\n\t\t\t\t\tcsv += point[header[j]];\n\t\t\t\t}\n\t\t\t\tcsv += \"\\n\";\n\t\t\t}\n\t\t\twindow.open(\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv));;\n\t\t}\n\t}\n}\n\nmodule.exports = createPlotter;\n// function createPlotter() {\n// \treturn Plotter.apply(this, arguments;\n// }\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plotter.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}