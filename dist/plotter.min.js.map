{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///plotter.min.js","webpack:///webpack/bootstrap 0a18fd219be0dbe10f52","webpack:///./src/entry.js","webpack:///./src/point.js","webpack:///./src/line.js","webpack:///./src/plot.js","webpack:///./src/plotter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Point","Line","Plot","Plotter","px","py","x","y","pa","pb","s","a","b","point","slope","calculateLabelSize","self","settings","ctx","font","labelPadding","measureText","width","labelFrequency","Math","max","range","floor","plotSize","gridSize","unitPerTick","yAxis","xAxis","yBleed","labelSizeVar","calculateLabelBleed","offset","domain","axisBleed","pixelPerUnit","yLabelBleed","labelBleedVar","arguments","offsetVar","domainVar","rangeVar","plotSizeVar","pixelPerUnitVar","unitPerTickVar","labelFrequencyVar","labelPrecisionVar","value","labelSize","labelBleed","labelPrecision","min","zeroBoundAxis","drawGrid","drawCoords","orientation","mouse","down","move","up","isDown","isUp","reCalculateLabels","key","hasOwnProperty","createPlotter","pageToPlot","plot","canvas","offsetLeft","height","offsetTop","pointInBounds","findPlotUnderPoint","i","plots","length","updateMouse","e","pageX","pageY","type","replace","buttons","button","updateTouch","changedTouches","event","MouseEvent","screenX","screenY","clientX","clientY","dispatchEvent","touches","preventDefault","refitCanvas","clipped","restore","size","padding","strokeStyle","lineWidth","strokeRect","drawPlot","translate","clearRect","debugBorders","fillStyle","fillRect","textAlign","textBaseline","beginPath","moveTo","lineTo","tickLabel","fillText","toFixed","stroke","axisOffset","rotate","PI","coordOffsetY","coordOffsetX","isNaN","round","currentPlot","plotNames","getContext","addEventListener","drawBorders","newPlot","name","push","clearPlot","unclip","undefined","save","rect","clip","editPlot","reCalcLabels","redrawCanvas","String","constructor","Object","prototype","toString","selectPlot","clear","pointOnPlot","plotToCanvas","plotPoint","r","fill","arc","plotLine","p1","p2","lineCap","plotSlope","plotPoly","points","closed","keys","plotFunction","func","xFunc","step","start","end","funcValue","plotText","text","printPlotData","pointObject","fields","csv","getPoints","header","j","window","open","encodeURIComponent"],"mappings":"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","file":"plotter.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Plotter\"] = factory();\n\telse\n\t\troot[\"Plotter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports.Point = __webpack_require__(1);\n\tmodule.exports.Line = __webpack_require__(2);\n\tmodule.exports.Plot = __webpack_require__(3);\n\tmodule.exports.Plotter = __webpack_require__(4);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A generic object for holding a point\n\t * @param {number} px - the x coordinate of the point\n\t * @param {number} py - the y coordinate of the point\n\t */\n\tfunction Point(px, py) {\n\t\tthis.x = px; \n\t\tthis.y = py;\n\t}\n\t\n\tmodule.exports = Point;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A generic object for holding a line.\n\t * @param {Point} pa - the first point on the line (used for calculating a line based on two points)\n\t * @param {Point} pb - the second point on the line (used for calculating a line based on two points)\n\t * @param {number} s - the slope of the line (used for calculating a line based on point-slope)\n\t * @param {Point} p - the point on the line (used for calculating a line based on point-slope)\n\t */\n\tfunction Line(pa, pb, s, p) {\n\t\tthis.a = pa; \n\t\tthis.b = pb; \n\t\tthis.point = p; \n\t\tthis.slope = s;\n\t} \n\t\n\tmodule.exports = Line;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Point = __webpack_require__(1);\n\t\n\t/**\n\t * Plots are what Points (and objects that consist of Points) are rendered on.\n\t * Plots describe the context in which Points are drawn, holding information\n\t * such as labels and a local coordinate system. Plotter uses this information\n\t * when plotting points and other objects.\n\t */\n\tfunction Plot()\n\t{\n\t\tvar ctx = arguments[1];\t\t\t\t\t\t\t// the context in which the \n\t\tvar settings = arguments[0];\n\t\t\n\t\tvar offsetVar = new Point(0, 0);\n\t\tvar domainVar = new Point(-10, 10);\n\t\tvar rangeVar = new Point(-10, 10);\n\t\tvar plotSizeVar = new Point(0, 0);\n\t\tvar pixelPerUnitVar = new Point(10, 10);\n\t\tvar unitPerTickVar = new Point(1, 1);\n\t\tvar labelFrequencyVar = new Point(2, 2);\n\t\tvar labelSizeVar = new Point(0, 0);\n\t\tvar labelBleedVar = new Point(0, 0);\n\t\tvar labelPrecisionVar = new Point(-1, -1);\n\t\t\n\t\n\t\t/**\n\t\t * Plot is a module. All variables enclosed are inaccesible from the \n\t\t * outside. self is returned to expose some of these variables\n\t\t * @type {Object}\n\t\t */\n\t\tvar self = {\t\n\t\n\t\n\t\t\t/**\n\t\t\t * @property {object} settings - a collection of settings that affect\n\t\t\t * how the plot is rendered\n\t\t\t * \n\t\t\t * @property {Point} settings.offset - by default, a graph is rendered \n\t\t\t * in the upper left corner of the canvas. This allows you to \n\t\t\t * reposition the plot relative to this point.\n\t\t\t *\n\t\t\t * @property {Point} settings.domain - the points along the x-axis that\n\t\t\t * the plot will display\n\t\t\t *\n\t\t\t * @property {Point} settings.range - the points along the y-axis that \n\t\t\t * the plot will display\n\t\t\t *\n\t\t\t * @property {Point} settins.pixelPerUnit - The number of pixels that \n\t\t\t * each unit of the plot will take up\n\t\t\t *\n\t\t\t * @property {Point} settings.plotSize - (readonly) The size of the \n\t\t\t * plot in pixels. This value is calculated by multiplying the pixels \n\t\t\t * per unit by the number of units in the graph (domain end - domain \n\t\t\t * start and range end - range start)\n\t\t\t *\n\t\t\t * @property {Point} settings.unitPerTick - A tick is wherever a line is drawn\n\t\t\t * on the plot. This controls how many units must pass before a tick is\n\t\t\t * drawn\n\t\t\t *\n\t\t\t * @property {Point} settings.gridSize - (readonly) The size of each block of \n\t\t\t * ticks on the plot. Calculated by multiplying the pixelPerUnit by the\n\t\t\t * unitPerTick\n\t\t\t *\n\t\t\t * @property {Point} settings.labelFrequency - This is the rate at which labels\n\t\t\t * are drawn on the ticks. It will default to a label for every tick\n\t\t\t *\n\t\t\t * @property {Point} settings.labelSize - (readonly) The size of the \n\t\t\t * label, where x is width and y is height, as calculated by \n\t\t\t * calculateLabelSize()\n\t\t\t *\n\t\t\t * @property {Point} settings.labelBleed - (readonly)\n\t\t\t *\n\t\t\t * @property {Point} settings.labelPrecision - This is a point that \n\t\t\t * determines how many decimals trail after the \".\" character. Values\n\t\t\t * less than 0 disable this feature.\n\t\t\t *\n\t\t\t * @property {string} settings.xAxis - the label for the x axis\n\t\t\t *\n\t\t\t * @property {string} settings.yAxis - the label for the y axis\n\t\t\t * \n\t\t\t * @property {boolean} settings.zeroBoundAxis - determines whether a \n\t\t\t * thick black line is drawn around the 0 axis. If false, the thick\n\t\t\t * black line will be drawn around the edges of the graph.\n\t\t\t * \n\t\t\t * @property {boolean} settings.drawGrid - determines whether the \n\t\t\t *\n\t\t\t * @property {boolean} settings.drawCoords - If true, the mouse\n\t\t\t * coordinates will be rendered. CURRENTLY NOT WORKING.\n\t\t\t * \n\t\t\t * @property {string} settings.orientation - determines where the\n\t\t\t * origin of the graph is rendered. It starts at the bottom left and\n\t\t\t * goes counterclockwise. \"a\" is the bottom left, \"b\" is the top left,\n\t\t\t * \"c\" is the top right, \"d\" is the bottom right.\n\t\t\t */\n\t\t\tsettings:\n\t\t\t{\n\t\t\t\tset offset(value) \n\t\t\t\t{\n\t\t\t\t\toffsetVar.x = value.x;\n\t\t\t\t\toffsetVar.y = value.y;\n\t\t\t\t},\n\t\t\t\tget offset() { return new Point(offsetVar.x + 75, offsetVar.y + 20); },\n\t\t\t\tset domain(value)\n\t\t\t\t{\n\t\t\t\t\tdomainVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\t\tdomainVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\t},\n\t\t\t\tget domain() { return new Point(domainVar.x, domainVar.y); },\n\t\t\t\tset range(value)\n\t\t\t\t{\n\t\t\t\t\trangeVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\t\trangeVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t\t},\n\t\t\t\tget range() { return new Point(rangeVar.x, rangeVar.y); },\n\t\t\t\tset pixelPerUnit(value)\n\t\t\t\t{\n\t\t\t\t\tpixelPerUnitVar.x = value.x != 0 ? value.x : pixelPerUnitVar.x;\n\t\t\t\t\tpixelPerUnitVar.y = value.y != 0 ? value.y : pixelPerUnitVar.y;\n\t\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t\t},\n\t\t\t\tget pixelPerUnit() { return new Point(pixelPerUnitVar.x, pixelPerUnitVar.y); },\n\t\t\t\tget plotSize() { return new Point(plotSizeVar.x, plotSizeVar.y); },\n\t\t\t\tset unitPerTick(value)\n\t\t\t\t{\n\t\t\t\t\tunitPerTickVar.x = value.x != 0 ? value.x : unitPerTickVar.x;\n\t\t\t\t\tunitPerTickVar.y = value.y != 0 ? value.y : unitPerTickVar.y;\n\t\t\t\t},\n\t\t\t\tget unitPerTick() { return new Point(unitPerTickVar.x, unitPerTickVar.y); },\n\t\t\t\tget gridSize()\n\t\t\t\t{ return new Point(this.unitPerTick.x * this.pixelPerUnit.x, this.unitPerTick.y * this.pixelPerUnit.y); },\n\t\t\t\tset labelFrequency(value)\n\t\t\t\t{\n\t\t\t\t\tlabelFrequencyVar.x = value.x >= 0 ? value.x : 0;\n\t\t\t\t\tlabelFrequencyVar.y = value.y >= 0 ? value.y : 0;\n\t\t\t\t},\n\t\t\t\tget labelFrequency() { return new Point(labelFrequencyVar.x, labelFrequencyVar.y); },\n\t\t\t\tget labelSize() { return new Point(labelSizeVar.x, labelSizeVar.y); },\n\t\t\t\tget labelBleed() { return new Point(labelBleedVar.x, labelBleedVar.y); },\n\t\t\t\tset labelPrecision(value)\n\t\t\t\t{\n\t\t\t\t\tlabelPrecisionVar.x = value.x >= 0 ? Math.min(20, Math.max(0, value.x)) : -1;\n\t\t\t\t\tlabelPrecisionVar.y = value.y >= 0 ? Math.min(20, Math.max(0, value.y)) : -1;\n\t\t\t\t},\n\t\t\t\tget labelPrecision() { return new Point(labelPrecisionVar.x, labelPrecisionVar.y); },\n\t\t\t\txAxis: \"xAxis\",\n\t\t\t\tyAxis: \"yAxis\",\n\t\t\t\tzeroBoundAxis: true,\n\t\t\t\tdrawGrid: true,\n\t\t\t\tdrawCoords: false,\n\t\t\t\torientation: \"a\"\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * @property {object} mouse - a collection of settings related to the \n\t\t\t * mouse in relation to the plot.\n\t\t\t *\n\t\t\t * @property {Point} mouse.down - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.move - The point in the plot's local\n\t\t\t * coordinates where the mouse has moved to\t \n\t\t\t * \n\t\t\t * @property {Point} mouse.up - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.isDown - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t *\n\t\t\t * @property {Point} mouse.isUp - The point in the plot's local\n\t\t\t * coordinates where the mouse was last down.\n\t\t\t */\n\t\t\tmouse:\n\t\t\t{\n\t\t\t\tdown: new Point(),\n\t\t\t\tmove: new Point(),\n\t\t\t\tup: new Point(),\n\t\t\t\tisDown: false,\n\t\t\t\tisUp: true\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Recalculate the size of the labels and the label bleed.\n\t\t\t */\n\t\t\treCalculateLabels: function() { \n\t\t\t\tcalculateLabelSize(); \n\t\t\t\tcalculateLabelBleed(); \n\t\t\t}\n\t\t}\n\t\t\n\t\t/**  \n\t\t * This initializes the Plot, merging the default settings object with the\n\t\t * object that was passed to the function as an argument. It then calculates\n\t\t * the size of the plot and the labels.\n\t\t */\n\t\tfor (var key in settings)\n\t\t\tif (self.settings.hasOwnProperty(key))\n\t\t\t\tself.settings[key] = settings[key];\n\t\t\n\t\tplotSizeVar.x = self.settings.pixelPerUnit.x * (self.settings.domain.y - self.settings.domain.x);\n\t\tplotSizeVar.y = self.settings.pixelPerUnit.y * (self.settings.range.y - self.settings.range.x);\n\t\t\n\t\tcalculateLabelSize();\n\t\tcalculateLabelBleed();\n\t\t\n\t\n\t\t/**\n\t\t * This function calculates padding that labels add to the graph. This is the\n\t\t * entire block of labels on each axis. It determines what the maximum \n\t\t * length of the value labels would be on each axis and then adds padding to \n\t\t * encompass the label of the axis.\n\t\t */\n\t\tfunction calculateLabelSize()\n\t\t{\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar s = self.settings;\n\t\t\t\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tvar labelPadding = ctx.measureText(\"M.\").width;\n\t\t\t\n\t\t\tif (s.labelFrequency.y != 0) {\n\t\t\t\tx += Math.max(ctx.measureText(s.range.x).width, ctx.measureText(s.range.x + Math.floor(s.plotSize.y / s.gridSize.y) * s.unitPerTick.y).width);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx += 6;\n\t\t\t}\n\t\t\tif (s.yAxis != \"\") {\n\t\t\t\tx += labelPadding;\n\t\t\t}\n\t\n\t\t\tif (s.labelFrequency.x != 0) {\n\t\t\t\ty += labelPadding;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty += 6;\n\t\t\t}\n\t\t\tif (s.xAxis != \"\") {\n\t\t\t\ty += labelPadding;\n\t\t\t}\n\t\t\tif (s.yAxis != \"\")\n\t\t\t{\n\t\t\t\tctx.font = \"24px Helvetica\";\n\t\t\t\tvar yBleed = ctx.measureText(s.yAxis).width * 0.5 - s.plotSize.y * 0.5;\n\t\t\t\ty = yBleed > y ? yBleed : y;\n\t\t\t}\n\t\t\t\n\t\t\tlabelSizeVar.x = x;\n\t\t\tlabelSizeVar.y = y;\n\t\t}\n\t\t\n\t\n\t\t/**\n\t\t * This function calculates the \"bleed\" of the labels. Essentially, if a \n\t\t * label value overflows, this provides a cutoff after which it will stop\n\t\t * rendering the text.\n\t\t * @return {[type]} [description]\n\t\t */\n\t\tfunction calculateLabelBleed()\n\t\t{\n\t\t\tvar s = self.settings;\n\t\t\tvar x = 0;\n\t\t\tvar y = s.labelFrequency.y != 0 ? -8 : 0;\n\t\t\t\n\t\t\tctx.font = \"16px Helvetica\";\n\t\t\t\n\t\t\tif (s.labelFrequency.x != 0) {\n\t\t\t\tx =  Math.max(s.offset.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.gridSize.x + ctx.measureText(s.domain.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.unitPerTick.x).width * 0.5 - (s.offset.x + s.plotSize.x), 0);\n\t\t\t}\n\t\t\t\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\t\n\t\t\tif (s.xAxis != \"\")\n\t\t\t{ \n\t\t\t\tvar axisBleed = Math.max(((s.domain.y - s.domain.x) * s.pixelPerUnit.x * 0.5 + ctx.measureText(s.xAxis).width * 0.5) - ((s.domain.y - s.domain.x) * s.pixelPerUnit.x), 0);\n\t\t\t\tx = x > axisBleed ? x : axisBleed;\n\t\t\t}\n\t\t\t\n\t\t\tif (s.yAxis != \"\")\n\t\t\t{\n\t\t\t\tvar yLabelBleed = s.plotSize.y * 0.5 - ctx.measureText(s.yAxis).width * 0.5;\n\t\t\t\ty = yLabelBleed < y ? yLabelBleed : y;\n\t\t\t}\n\t\t\t\n\t\t\tlabelBleedVar.x = x;\n\t\t\tlabelBleedVar.y = y;\n\t\t}\n\t\t\n\t\treturn self;\n\t}\n\t\n\tmodule.exports = Plot;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Point = __webpack_require__(1);\n\tvar Plot = __webpack_require__(3);\n\tvar Line = __webpack_require__(2);\n\t\n\t/**\n\t * Creates a Plotter object. Given a HTML Canvas Element, this function creates\n\t * a series of functions for interacting with it. It also attaches some of\n\t * these functions to event listeners for mouse and touch events.\n\t *\n\t * @param {HTMLCanvasElement} canvas - The Canvas element that plots will be\n\t * drawn on.\n\t *\n\t * @param {Point} padding - a Point that describs how much padding\n\t * to apply to the canvas element before rendering elements.\n\t * \n\t * @return {Plotter} - An object that collects properties and methods for \n\t * interacting with the canvas element passed to the function.\n\t */\n\tfunction createPlotter()\n\t{\n\t\tvar canvas, ctx;\n\t\tvar plots = [];\n\t\tvar plotNames = {};\n\t\tvar currentPlot, clipped = false;\n\t\tvar debugBorders = false;\n\t\tvar padding = typeof arguments[1] !== \"undefined\" ? arguments[1] : new Point(0, 0);\n\t\t\n\t\tcanvas = arguments[0];\n\t\tctx = canvas.getContext(\"2d\");\n\t\t\t\n\t\tcanvas.addEventListener(\"mousedown\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"mousemove\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"mouseup\", function(e){updateMouse(e);}, false);\n\t\tcanvas.addEventListener(\"touchstart\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchmove\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchend\", function(e){updateTouch(e);}, false);\n\t\tcanvas.addEventListener(\"touchcancel\", function(e){updateTouch(e);}, false);\n\t\t\n\t\tfunction pageToPlot(p, plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\tvar x = (p.x - canvas.offsetLeft - s.offset.x) / s.pixelPerUnit.x + s.domain.x;\n\t\t\tvar y = (canvas.height - (p.y - canvas.offsetTop) - (canvas.height - (s.offset.y + s.plotSize.y))) / s.pixelPerUnit.y + s.range.x;\n\t\t\treturn new Point(x, y);\n\t\t}\n\t\t\n\t\tfunction pointInBounds(p, plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\treturn (p.x >= s.domain.x && p.x <= s.domain.y && p.y >= s.range.x && p.y <= s.range.y)\n\t\t}\n\t\t\n\t\tfunction findPlotUnderPoint(p)\n\t\t{\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t\tif (pointInBounds(pageToPlot(p, plots[i]), plots[i]))\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tfunction updateMouse(e)\n\t\t{\n\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\tif (plot == -1)\n\t\t\t\treturn;\n\t\t\tplot = plots[plot];\n\t\t\t\n\t\t\tvar p = pageToPlot(new Point(e.pageX, e.pageY), plot);\n\t\t\tvar type = e.type.replace(\"mouse\", '');\n\t\t\t\n\t\t\tif ((type == \"down\" || type == \"move\") && (!(e.buttons & 1) && e.button != 0))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tplot.mouse[type].x = p.x;\n\t\t\tplot.mouse[type].y = p.y;\n\t\t\tif (type == \"down\")\n\t\t\t{\n\t\t\t\tplot.mouse.isDown = true;\n\t\t\t\tplot.mouse.isUp = false;\n\t\t\t}\n\t\t\telse if (type == \"up\")\n\t\t\t{\n\t\t\t\tplot.mouse.isDown = false;\n\t\t\t\tplot.mouse.isUp = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction updateTouch(e)\n\t\t{\t\n\t\t\tvar type = e.type.replace(\"touch\",'');\n\t\t\t\n\t\t\tfor(var i = 0; i < e.changedTouches.length; i++)\n\t\t\t{\n\t\t\t\tvar touchID, event;\n\t\t\t\t\n\t\t\t\tswitch(type)\n\t\t\t\t{\n\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mousedown\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"move\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mousemove\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"cancel\":\n\t\t\t\t\tcase \"end\":\n\t\t\t\t\t\tevent = new MouseEvent(\"mouseup\",\n\t\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcanvas.dispatchEvent(event);\n\t\t\t}\n\t\t\t\n\t\t\tif (e.touches.length > 0)\n\t\t\t{\n\t\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\t\tif (plot != -1)\n\t\t\t\t{\n\t\t\t\t\tplots[plot].mouse.isDown = true;\n\t\t\t\t\tplots[plot].mouse.isUp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (e.touches.length == 1 && type == \"move\")\n\t\t\t\te.preventDefault();\n\t\t}\n\t\t\n\t\tfunction refitCanvas()\n\t\t{\n\t\t\tif (plots.length == 0)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.restore();\n\t\t\t\tclipped = false;\n\t\t\t}\n\t\t\t\n\t\t\tvar size = new Point(0, 0);\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t{\n\t\t\t\tvar s = plots[i].settings;\n\t\t\t\tsize.x = Math.max(size.x, s.offset.x + s.plotSize.x + s.labelBleed.x);\n\t\t\t\tsize.y = Math.max(size.y, s.offset.y + s.plotSize.y + s.labelSize.y);\n\t\t\t}\t\t\t\n\t\t\tcanvas.width = size.x + padding.x + 10;\n\t\t\tcanvas.height = size.y + padding.y + 10;\n\t\t\t\n\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\tctx.lineWidth = 2;\n\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t\n\t\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\t\tdrawPlot(plots[i]);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Renders the specified plot on the canvas. This function takes a Plot\n\t\t * object and then uses its settings to draw it on the canvas.\n\t\t * @param  {Plot} plot - the Plot object we want to render on the canvas\n\t\t */\n\t\tfunction drawPlot(plot)\n\t\t{\n\t\t\tvar s = plot.settings;\n\t\t\t\n\t\t\tctx.translate(s.offset.x, s.offset.y);\n\t\t\tctx.clearRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t\tif (debugBorders)\n\t\t\t{\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t\t}\t\n\t\t\tctx.lineWidth = 2;\n\t\t\t\n\t\t\t//plot\n\t\t\tctx.fillStyle = \"#F8F8F8\";\n\t\t\tctx.fillRect(0, 0, s.plotSize.x, s.plotSize.y);\n\t\t\tctx.fillStyle = \"#000000\";\n\t\t\tctx.strokeStyle = \"#E0E0E0\";\n\t\t\tctx.font = \"16px Helvetica\";\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.beginPath();\n\t\t\t\tfor( var i = 0; i <= s.plotSize.x / s.gridSize.x; i++)\n\t\t\t\t{\n\t\t\t\t\tvar x = i * s.gridSize.x;\n\t\t\t\t\tif (s.orientation==\"c\" || s.orientation==\"d\")\n\t\t\t\t\t\tx = s.plotSize.x - x;\n\t\t\t\t\t\n\t\t\t\t\tif (s.drawGrid)\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.moveTo(x, s.plotSize.y);\n\t\t\t\t\t\tctx.lineTo(x, 0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!(i % s.labelFrequency.x) && s.labelFrequency.x > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tickLabel = s.domain.x + i * s.unitPerTick.x;\n\t\t\t\t\t\tctx.fillText( s.labelPrecision.x == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.x), x, s.plotSize.y + 5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\tctx.textBaseline = \"middle\";\n\t\t\t\tfor( var i = 0; i <= s.plotSize.y / s.gridSize.y; i++)\n\t\t\t\t{\n\t\t\t\t\tvar y = i * s.gridSize.y;\n\t\t\t\t\tif (!(s.orientation==\"b\" || s.orientation==\"c\"))\n\t\t\t\t\t\ty = s.plotSize.y - y;\t\n\t\t\t\t\tif (s.drawGrid)\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.moveTo(0, y);\n\t\t\t\t\t\tctx.lineTo(s.plotSize.x, y);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(i % s.labelFrequency.y) && s.labelFrequency.y > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tickLabel = s.range.x + i * s.unitPerTick.y;\n\t\t\t\t\t\tctx.fillText(s.labelPrecision.y == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.y), -5, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t//axis\n\t\t\tctx.strokeStyle = \"#000000\";\n\t\t\tctx.lineWidth = 1;\n\t\t\tctx.beginPath();\n\t\t\t\tvar axisOffset = new Point(\n\t\t\t\t(s.zeroBoundAxis ? Math.max(0, Math.min(s.plotSize.x, ((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : -s.domain.x) * s.pixelPerUnit.x)) : (s.orientation==\"c\"||s.orientation==\"d\") ? s.plotSize.x : 0),\n\t\t\t\t(s.zeroBoundAxis ? Math.min(s.plotSize.y, Math.max(0, ((s.orientation==\"b\"||s.orientation==\"c\") ? -s.range.x : s.range.y) * s.pixelPerUnit.y)) : (s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.plotSize.y));\n\t\t\t\tctx.moveTo(axisOffset.x, 0);\n\t\t\t\tctx.lineTo(axisOffset.x, s.plotSize.y);\n\t\t\t\tctx.moveTo(0, axisOffset.y);\n\t\t\t\tctx.lineTo(s.plotSize.x, axisOffset.y);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t//x axis label\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"bottom\";\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tctx.fillText(s.xAxis, s.plotSize.x * 0.5, s.plotSize.y + s.labelSize.y);\n\t\t\t\n\t\t\t//y axis label\n\t\t\tctx.translate(-s.labelSize.x,  s.plotSize.y * 0.5);\n\t\t\tctx.rotate(3 * Math.PI * 0.5);\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(s.yAxis, 0, 0);\n\t\t\tctx.rotate(-3 * Math.PI * 0.5);\n\t\t\tctx.translate(s.labelSize.x,  -(s.plotSize.y * 0.5));\n\t\t\t\n\t\t\t//coordinates\n\t\t\tif (s.drawCoords) //needs to be redone entirely\n\t\t\t{\n\t\t\t\tvar coordOffsetY = Math.max(ctx.measureText(s.domain.x).width, ctx.measureText(s.domain.y).width);\n\t\t\t\tvar coordOffsetX = coordOffsetY * 2 + ctx.measureText(\"y: \").width;\n\t\t\t\tctx.textAlign = \"left\";\n\t\t\t\tctx.textBaseline = \"bottom\";\n\t\t\t\tctx.fillText(\"x: \" + (isNaN(Math.round(this.mouse.move.x)) ? 0 : Math.round(this.mouse.move.x)), s.plotSize.x - coordOffsetX - 20, s.plotSize.y + s.labelSize.y);\n\t\t\t\tctx.fillText(\"y: \" + (isNaN(Math.round(this.mouse.move.y)) ? 0 : Math.round(this.mouse.move.y)), s.plotSize.x - coordOffsetY - 10, s.plotSize.y + s.labelSize.y);\n\t\t\t}\n\t\t\t\n\t\t\tctx.translate(-s.offset.x, -s.offset.y);\n\t\t}\n\t\t\n\t\treturn {\n\t\t\tset drawBorders(value) { debugBorders = value; },\n\t\t\tget drawBorders() { return debugBorders; },\n\t\t\tnewPlot: function(settings, name)\n\t\t\t{\n\t\t\t\tplot = new Plot(settings, ctx);\n\t\t\t\tplots.push(plot);\n\t\t\t\t\n\t\t\t\tif (typeof name !== \"undefined\")\n\t\t\t\t\tplotNames[name] = plots.length - 1;\n\t\t\t\t\n\t\t\t\trefitCanvas();\n\t\t\t\tdrawPlot(plot);\n\t\t\t\t\n\t\t\t\treturn plots.length - 1;\n\t\t\t},\n\t\t\tclearPlot: function(unclip)\n\t\t\t{\n\t\t\t\tunclip = typeof unclip !== \"undefined\" ? unclip : false;\n\t\t\t\t\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped && unclip)\n\t\t\t\t\tctx.restore();\n\t\t\t\t\n\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t},\n\t\t\teditPlot: function(plot, settings, reCalcLabels, redrawCanvas)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\t\n\t\t\t\tredrawCanvas = typeof redrawCanvas !== \"undefined\" ? redrawCanvas : false;\n\t\t\t\treCalcLabels = typeof reCalcLabels !== \"undefined\" ? reCalcLabels : false;\n\t\t\t\t\n\t\t\t\tif (plot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t\tctx.restore();\n\t\t\t\t\n\t\t\t\tif (redrawCanvas)\n\t\t\t\t{\n\t\t\t\t\tctx.clearRect(0,0, canvas.width, canvas.height);\n\t\t\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var key in settings)\n\t\t\t\t\tif (plot.settings.hasOwnProperty(key))\n\t\t\t\t\t\tplot.settings[key] = settings[key];\n\t\t\t\t\n\t\t\t\tif (reCalcLabels)\n\t\t\t\t\tplot.reCalculateLabels();\n\t\t\t\t\n\t\t\t\tdrawPlot(plot);\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t},\n\t\t\tselectPlot: function(plot, clear, clip)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tclear = typeof clear !== \"undefined\" ? clear : true;\n\t\t\t\tclip = typeof clip !== \"undefined\" ? clip : true;\n\t\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\t\n\t\t\t\tif (plot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (clipped)\n\t\t\t\t\tctx.restore();\n\t\t\t\tcurrentPlot = plot;\n\t\t\t\tif (clear)\n\t\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\t\n\t\t\t\tif (clip)\n\t\t\t\t{\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\t\tctx.clip();\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\t\t\t\telse if (clipped)\n\t\t\t\t\tclipped = false;\n\t\t\t},\n\t\n\t\n\t\t\tget ctx() { \n\t\t\t\treturn ctx; },\n\t\n\t\n\t\t\tget mouse()\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\treturn currentPlot.mouse;\n\t\t\t},\n\t\n\t\n\t\t\tget settings()\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\treturn currentPlot.settings;\n\t\t\t},\n\t\n\t\n\t\t\tpointOnPlot: function(p, plot)\n\t\t\t{\n\t\t\t\tif (typeof plot === \"number\" && \n\t\t\t\t   (plot >= 0 && plot <= plots.length - 1)) {\n\t\t\t\t\t\tplot = plots[plot];\n\t\t\t\t}\n\t\t\t\telse if (typeof plot === \"string\" || \n\t\t\t\t\t\t plot instanceof String || \n\t\t\t\t\t\t Object.prototype.toString.call(plot) == \"[object String]\") {\n\t\n\t\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t\t}\n\t\t\t\telse if (plot.hasOwnProperty('constructor') && plot.constructor == String) {\n\t\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tplot = currentPlot;\n\t\t\t\t\n\t\t\t\treturn pointInBounds(p, plot);\n\t\t\t},\n\t\n\t\n\t\t\tplotToCanvas: function(p)\n\t\t\t{\n\t\t\t\tvar s = currentPlot.settings;\n\t\t\t\tvar x = (((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : 2 * p.x) - p.x - ((s.orientation==\"c\"||s.orientation==\"d\") ? 0 : s.domain.x)) * s.pixelPerUnit.x + s.offset.x;\n\t\t\t\tvar y = s.plotSize.y - ((((s.orientation==\"b\"||s.orientation==\"c\") ? s.range.y : 2 * p.y) - p.y - ((s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.range.x)) * s.pixelPerUnit.y) + s.offset.y;\n\t\t\t\treturn new Point(x, y);\n\t\t\t},\n\t\n\t\n\t\t\tplotPoint: function(p, r, fill)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tr = typeof r !== \"undefined\" ? r : 2;\n\t\t\t\tfill = typeof fill !== \"undefined\" ? fill : true;\n\t\t\t\t\n\t\t\t\tp = this.plotToCanvas(p);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n\t\t\t\tif (fill)\n\t\t\t\t\tctx.fill();\n\t\t\t\telse\n\t\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\tplotLine: function(p1, p2)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tp1 = this.plotToCanvas(p1);\n\t\t\t\tp2 = this.plotToCanvas(p2);\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\tplotSlope: function(p, slope)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar p1 = new Point(currentPlot.settings.domain.x, p.y - slope * (p.x - currentPlot.settings.domain.x));\n\t\t\t\tif (!pointInBounds(p1, currentPlot))\n\t\t\t\t{\n\t\t\t\t\tp1.y = p1.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\t\tp1.x = p.x - (p.y - p1.y)/slope;\n\t\t\t\t}\n\t\t\t\tvar p2 = new Point(currentPlot.settings.domain.y, p.y - slope * (p.x - currentPlot.settings.domain.y));\n\t\t\t\tif (!pointInBounds(p2, currentPlot))\n\t\t\t\t{\n\t\t\t\t\tp2.y = p2.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\t\tp2.x = p.x - (p.y - p2.y)/slope;\n\t\t\t\t}\n\t\t\t\tthis.plotLine(p1, p2);\n\t\t\t\t\n\t\t\t\treturn new Line(p1, p2, slope, new Point(p.x, p.y));\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Take an array of vertices and add them to the plot sequentially.\n\t\t\t * When all of them have been added, draw them on the canvas.\n\t\t\t * \n\t\t\t * @param  {Array.<Point>} points - an array that contains all of the \n\t\t\t * vertices of the polygon. They will be plotted in the order they are\n\t\t\t * listed in the array.\n\t\t\t * \n\t\t\t * @param  {[boolean]} closed - a boolean value that specifies whether \n\t\t\t * the vertices should be connected when the plot is rendered. By\n\t\t\t * default, the vertices will not be rendered.\n\t\t\t */\n\t\t\tplotPoly: function(points, closed)\n\t\t\t{\n\t\t\t\tvar length = Object.keys(points).length;\n\t\t\t\tif (currentPlot == undefined || length < 2)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tclosed = typeof closed !== \"undefined\" ? closed : false;\n\t\t\t\t\n\t\t\t\tif (typeof points == \"undefined\")\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\t\t\t\tfor (var i = 0; i < length - 1; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = this.plotToCanvas(points[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t}\n\t\t\t\t\tif (closed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = this.plotToCanvas(points[0]);\n\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t}\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Given a mathematical function, render it on a plot. This function\n\t\t\t * iterates from the start value to the end value. At each point, it\n\t\t\t * calculates the point at that value using the given function.\n\t\t\t * \n\t\t\t * @param  {Function} func - the function we want to plot on the graph.\n\t\t\t * It takes a numeric value as a parameter and returns a numeric value.\n\t\t\t * \n\t\t\t * @param  {[boolean]} xFunc - this specifies whether the function is\n\t\t\t * to be graphed along the x-axis or the y-axis. It's default value is\n\t\t\t * true.\n\t\t\t * \n\t\t\t * @param  {[number]} step - the value to increment by when calculating\n\t\t\t * function points. By default, it will increment by 1.\n\t\t\t * \n\t\t\t * @param  {[number]} start - this is the value that the function will\n\t\t\t * start calculating values at. By default, it will use the start value\n\t\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t\t * \n\t\t\t * @param  {[number]} end - this is the value that the function will\n\t\t\t * stop calculating values at. By default, it will use the end value\n\t\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t\t */\n\t\t\tplotFunction: function(func, xFunc, step, start, end)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\txFunc = typeof xFunc !== \"undefined\" ? xFunc : true;\n\t\t\t\tstep = typeof step !== \"undefined\" ? step : 1;\n\t\t\t\tstart = typeof start !== \"undefined\" ? start : (xFunc ? currentPlot.settings.domain.x : currentPlot.settings.range.x);\n\t\t\t\tend = typeof end !== \"undefined\" ? end : (xFunc ? currentPlot.settings.domain.y : currentPlot.settings.range.y);\n\t\n\t\t\t\tvar i = start, funcValue;\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\tctx.beginPath();\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * This loops iterates, adding the amount specified by timestep\n\t\t\t\t\t * value to the count each time. At each time. If the value exists,\n\t\t\t\t\t * it draws a line to the new location. It does this until the value\n\t\t\t\t\t * of the count is greater than or equal to the end value.\n\t\t\t\t\t */\n\t\t\t\t\twhile (i < end)\n\t\t\t\t\t{\n\t\t\t\t\t\tfuncValue = func(i);\n\t\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\t\tvar p = new Point(xFunc?i:funcValue, xFunc?funcValue:i);\n\t\t\t\t\t\t\tp = this.plotToCanvas(p);\t\t\n\t\t\t\t\t\t\tif (i != start) {\n\t\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti+= step;\n\t\t\t\t\t\tif (i > end) {\n\t\t\t\t\t\t\ti = end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/*\n\t\t\t\t\t * an edge case. In the event that start is greater than or\n\t\t\t\t\t * equal to end, plot that point\n\t\t\t\t\t */\n\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\t//points.push(new Point(xFunc?i:funcValue, xFunc?funcValue:i));\n\t\t\t\t\t}\n\t\n\t\t\t\tctx.stroke();\n\t\t\t},\n\t\n\t\n\t\t\t/** \n\t\t\t * If a plot is currently specified, draw the text at the specified\n\t\t\t * point on the plot.\n\t\t\t * @param  {string} text  - The text the user wants to write on the canvas\n\t\t\t * @param  {Point} point  - The point, in the plot's local coordinate\n\t\t\t * system, that the text will be rendered at.\n\t\t\t */\n\t\t\tplotText: function(text, point)\n\t\t\t{\n\t\t\t\tif (currentPlot == undefined)\n\t\t\t\t\treturn;\n\t\t\t\tpoint = typeof point !== \"undefined\" ? point : new Point(currentPlot.settings.domain.x + (currentPlot.settings.domain.y - currentPlot.settings.domain.x) * 0.5, currentPlot.settings.range.x + (currentPlot.settings.range.y - currentPlot.settings.range.x) * 0.5);\n\t\t\t\tpoint = this.plotToCanvas(point);\n\t\t\t\tctx.fillText(text, point.x, point.y);\n\t\t\t},\n\t\n\t\n\t\t\t/**\n\t\t\t * Print the plot data of the pointObject as CSV. The function accepts\n\t\t\t * a PointObject, retrives its points and parses the specified fields\n\t\t\t * as a CSV file. If no fields are specified, the function will print\n\t\t\t * all of them.\n\t\t\t *\n\t\t\t * @param  {PointObject} pointObject - the object from which plotter\n\t\t\t * retrieves the points.\n\t\t\t * @param  {[Array]} fields - an array of the fields to display\n\t\t\t */\n\t\t\tprintPlotData: function(pointObject, fields) {\n\t\t\t\tvar csv = \"\";\n\t\t\t\tvar points = pointObject.getPoints();\n\t\t\t\tvar header = fields ? fields : Object.keys(points[0]);\n\t\t\t\t\n\t\t\t\tvar point = {};\n\t\t\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tif (i === 0) {\t\n\t\t\t\t\t\tfor(var j = 0; j < header.length; j++) {\n\t\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcsv += header[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tfor (var j = 0; j < header.length; j++) {\n\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += point[header[j]];\n\t\t\t\t\t}\n\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t}\n\t\t\t\twindow.open(\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv));;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmodule.exports = createPlotter;\n\t// function createPlotter() {\n\t// \treturn Plotter.apply(this, arguments;\n\t// }\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plotter.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0a18fd219be0dbe10f52\n **/","module.exports.Point = require('./point');\nmodule.exports.Line = require('./line');\nmodule.exports.Plot = require('./plot');\nmodule.exports.Plotter = require('./plotter');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","/**\n * A generic object for holding a point\n * @param {number} px - the x coordinate of the point\n * @param {number} py - the y coordinate of the point\n */\nfunction Point(px, py) {\n\tthis.x = px; \n\tthis.y = py;\n}\n\nmodule.exports = Point;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/point.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * A generic object for holding a line.\n * @param {Point} pa - the first point on the line (used for calculating a line based on two points)\n * @param {Point} pb - the second point on the line (used for calculating a line based on two points)\n * @param {number} s - the slope of the line (used for calculating a line based on point-slope)\n * @param {Point} p - the point on the line (used for calculating a line based on point-slope)\n */\nfunction Line(pa, pb, s, p) {\n\tthis.a = pa; \n\tthis.b = pb; \n\tthis.point = p; \n\tthis.slope = s;\n} \n\nmodule.exports = Line;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/line.js\n ** module id = 2\n ** module chunks = 0\n **/","var Point = require('./point');\n\n/**\n * Plots are what Points (and objects that consist of Points) are rendered on.\n * Plots describe the context in which Points are drawn, holding information\n * such as labels and a local coordinate system. Plotter uses this information\n * when plotting points and other objects.\n */\nfunction Plot()\n{\n\tvar ctx = arguments[1];\t\t\t\t\t\t\t// the context in which the \n\tvar settings = arguments[0];\n\t\n\tvar offsetVar = new Point(0, 0);\n\tvar domainVar = new Point(-10, 10);\n\tvar rangeVar = new Point(-10, 10);\n\tvar plotSizeVar = new Point(0, 0);\n\tvar pixelPerUnitVar = new Point(10, 10);\n\tvar unitPerTickVar = new Point(1, 1);\n\tvar labelFrequencyVar = new Point(2, 2);\n\tvar labelSizeVar = new Point(0, 0);\n\tvar labelBleedVar = new Point(0, 0);\n\tvar labelPrecisionVar = new Point(-1, -1);\n\t\n\n\t/**\n\t * Plot is a module. All variables enclosed are inaccesible from the \n\t * outside. self is returned to expose some of these variables\n\t * @type {Object}\n\t */\n\tvar self = {\t\n\n\n\t\t/**\n\t\t * @property {object} settings - a collection of settings that affect\n\t\t * how the plot is rendered\n\t\t * \n\t\t * @property {Point} settings.offset - by default, a graph is rendered \n\t\t * in the upper left corner of the canvas. This allows you to \n\t\t * reposition the plot relative to this point.\n\t\t *\n\t\t * @property {Point} settings.domain - the points along the x-axis that\n\t\t * the plot will display\n\t\t *\n\t\t * @property {Point} settings.range - the points along the y-axis that \n\t\t * the plot will display\n\t\t *\n\t\t * @property {Point} settins.pixelPerUnit - The number of pixels that \n\t\t * each unit of the plot will take up\n\t\t *\n\t\t * @property {Point} settings.plotSize - (readonly) The size of the \n\t\t * plot in pixels. This value is calculated by multiplying the pixels \n\t\t * per unit by the number of units in the graph (domain end - domain \n\t\t * start and range end - range start)\n\t\t *\n\t\t * @property {Point} settings.unitPerTick - A tick is wherever a line is drawn\n\t\t * on the plot. This controls how many units must pass before a tick is\n\t\t * drawn\n\t\t *\n\t\t * @property {Point} settings.gridSize - (readonly) The size of each block of \n\t\t * ticks on the plot. Calculated by multiplying the pixelPerUnit by the\n\t\t * unitPerTick\n\t\t *\n\t\t * @property {Point} settings.labelFrequency - This is the rate at which labels\n\t\t * are drawn on the ticks. It will default to a label for every tick\n\t\t *\n\t\t * @property {Point} settings.labelSize - (readonly) The size of the \n\t\t * label, where x is width and y is height, as calculated by \n\t\t * calculateLabelSize()\n\t\t *\n\t\t * @property {Point} settings.labelBleed - (readonly)\n\t\t *\n\t\t * @property {Point} settings.labelPrecision - This is a point that \n\t\t * determines how many decimals trail after the \".\" character. Values\n\t\t * less than 0 disable this feature.\n\t\t *\n\t\t * @property {string} settings.xAxis - the label for the x axis\n\t\t *\n\t\t * @property {string} settings.yAxis - the label for the y axis\n\t\t * \n\t\t * @property {boolean} settings.zeroBoundAxis - determines whether a \n\t\t * thick black line is drawn around the 0 axis. If false, the thick\n\t\t * black line will be drawn around the edges of the graph.\n\t\t * \n\t\t * @property {boolean} settings.drawGrid - determines whether the \n\t\t *\n\t\t * @property {boolean} settings.drawCoords - If true, the mouse\n\t\t * coordinates will be rendered. CURRENTLY NOT WORKING.\n\t\t * \n\t\t * @property {string} settings.orientation - determines where the\n\t\t * origin of the graph is rendered. It starts at the bottom left and\n\t\t * goes counterclockwise. \"a\" is the bottom left, \"b\" is the top left,\n\t\t * \"c\" is the top right, \"d\" is the bottom right.\n\t\t */\n\t\tsettings:\n\t\t{\n\t\t\tset offset(value) \n\t\t\t{\n\t\t\t\toffsetVar.x = value.x;\n\t\t\t\toffsetVar.y = value.y;\n\t\t\t},\n\t\t\tget offset() { return new Point(offsetVar.x + 75, offsetVar.y + 20); },\n\t\t\tset domain(value)\n\t\t\t{\n\t\t\t\tdomainVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\tdomainVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t},\n\t\t\tget domain() { return new Point(domainVar.x, domainVar.y); },\n\t\t\tset range(value)\n\t\t\t{\n\t\t\t\trangeVar.x = value.x < value.y ? value.x : value.y;\n\t\t\t\trangeVar.y = value.x < value.y ? value.y : value.x;\n\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t},\n\t\t\tget range() { return new Point(rangeVar.x, rangeVar.y); },\n\t\t\tset pixelPerUnit(value)\n\t\t\t{\n\t\t\t\tpixelPerUnitVar.x = value.x != 0 ? value.x : pixelPerUnitVar.x;\n\t\t\t\tpixelPerUnitVar.y = value.y != 0 ? value.y : pixelPerUnitVar.y;\n\t\t\t\tplotSizeVar.x = this.pixelPerUnit.x * (this.domain.y - this.domain.x);\n\t\t\t\tplotSizeVar.y = this.pixelPerUnit.y * (this.range.y - this.range.x);\n\t\t\t},\n\t\t\tget pixelPerUnit() { return new Point(pixelPerUnitVar.x, pixelPerUnitVar.y); },\n\t\t\tget plotSize() { return new Point(plotSizeVar.x, plotSizeVar.y); },\n\t\t\tset unitPerTick(value)\n\t\t\t{\n\t\t\t\tunitPerTickVar.x = value.x != 0 ? value.x : unitPerTickVar.x;\n\t\t\t\tunitPerTickVar.y = value.y != 0 ? value.y : unitPerTickVar.y;\n\t\t\t},\n\t\t\tget unitPerTick() { return new Point(unitPerTickVar.x, unitPerTickVar.y); },\n\t\t\tget gridSize()\n\t\t\t{ return new Point(this.unitPerTick.x * this.pixelPerUnit.x, this.unitPerTick.y * this.pixelPerUnit.y); },\n\t\t\tset labelFrequency(value)\n\t\t\t{\n\t\t\t\tlabelFrequencyVar.x = value.x >= 0 ? value.x : 0;\n\t\t\t\tlabelFrequencyVar.y = value.y >= 0 ? value.y : 0;\n\t\t\t},\n\t\t\tget labelFrequency() { return new Point(labelFrequencyVar.x, labelFrequencyVar.y); },\n\t\t\tget labelSize() { return new Point(labelSizeVar.x, labelSizeVar.y); },\n\t\t\tget labelBleed() { return new Point(labelBleedVar.x, labelBleedVar.y); },\n\t\t\tset labelPrecision(value)\n\t\t\t{\n\t\t\t\tlabelPrecisionVar.x = value.x >= 0 ? Math.min(20, Math.max(0, value.x)) : -1;\n\t\t\t\tlabelPrecisionVar.y = value.y >= 0 ? Math.min(20, Math.max(0, value.y)) : -1;\n\t\t\t},\n\t\t\tget labelPrecision() { return new Point(labelPrecisionVar.x, labelPrecisionVar.y); },\n\t\t\txAxis: \"xAxis\",\n\t\t\tyAxis: \"yAxis\",\n\t\t\tzeroBoundAxis: true,\n\t\t\tdrawGrid: true,\n\t\t\tdrawCoords: false,\n\t\t\torientation: \"a\"\n\t\t},\n\n\n\t\t/**\n\t\t * @property {object} mouse - a collection of settings related to the \n\t\t * mouse in relation to the plot.\n\t\t *\n\t\t * @property {Point} mouse.down - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.move - The point in the plot's local\n\t\t * coordinates where the mouse has moved to\t \n\t\t * \n\t\t * @property {Point} mouse.up - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.isDown - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t *\n\t\t * @property {Point} mouse.isUp - The point in the plot's local\n\t\t * coordinates where the mouse was last down.\n\t\t */\n\t\tmouse:\n\t\t{\n\t\t\tdown: new Point(),\n\t\t\tmove: new Point(),\n\t\t\tup: new Point(),\n\t\t\tisDown: false,\n\t\t\tisUp: true\n\t\t},\n\n\n\t\t/**\n\t\t * Recalculate the size of the labels and the label bleed.\n\t\t */\n\t\treCalculateLabels: function() { \n\t\t\tcalculateLabelSize(); \n\t\t\tcalculateLabelBleed(); \n\t\t}\n\t}\n\t\n\t/**  \n\t * This initializes the Plot, merging the default settings object with the\n\t * object that was passed to the function as an argument. It then calculates\n\t * the size of the plot and the labels.\n\t */\n\tfor (var key in settings)\n\t\tif (self.settings.hasOwnProperty(key))\n\t\t\tself.settings[key] = settings[key];\n\t\n\tplotSizeVar.x = self.settings.pixelPerUnit.x * (self.settings.domain.y - self.settings.domain.x);\n\tplotSizeVar.y = self.settings.pixelPerUnit.y * (self.settings.range.y - self.settings.range.x);\n\t\n\tcalculateLabelSize();\n\tcalculateLabelBleed();\n\t\n\n\t/**\n\t * This function calculates padding that labels add to the graph. This is the\n\t * entire block of labels on each axis. It determines what the maximum \n\t * length of the value labels would be on each axis and then adds padding to \n\t * encompass the label of the axis.\n\t */\n\tfunction calculateLabelSize()\n\t{\n\t\tvar x = 0;\n\t\tvar y = 0;\n\t\tvar s = self.settings;\n\t\t\n\t\tctx.font = \"24px Helvetica\";\n\t\tvar labelPadding = ctx.measureText(\"M.\").width;\n\t\t\n\t\tif (s.labelFrequency.y != 0) {\n\t\t\tx += Math.max(ctx.measureText(s.range.x).width, ctx.measureText(s.range.x + Math.floor(s.plotSize.y / s.gridSize.y) * s.unitPerTick.y).width);\n\t\t}\n\t\telse {\n\t\t\tx += 6;\n\t\t}\n\t\tif (s.yAxis != \"\") {\n\t\t\tx += labelPadding;\n\t\t}\n\n\t\tif (s.labelFrequency.x != 0) {\n\t\t\ty += labelPadding;\n\t\t}\n\t\telse {\n\t\t\ty += 6;\n\t\t}\n\t\tif (s.xAxis != \"\") {\n\t\t\ty += labelPadding;\n\t\t}\n\t\tif (s.yAxis != \"\")\n\t\t{\n\t\t\tctx.font = \"24px Helvetica\";\n\t\t\tvar yBleed = ctx.measureText(s.yAxis).width * 0.5 - s.plotSize.y * 0.5;\n\t\t\ty = yBleed > y ? yBleed : y;\n\t\t}\n\t\t\n\t\tlabelSizeVar.x = x;\n\t\tlabelSizeVar.y = y;\n\t}\n\t\n\n\t/**\n\t * This function calculates the \"bleed\" of the labels. Essentially, if a \n\t * label value overflows, this provides a cutoff after which it will stop\n\t * rendering the text.\n\t * @return {[type]} [description]\n\t */\n\tfunction calculateLabelBleed()\n\t{\n\t\tvar s = self.settings;\n\t\tvar x = 0;\n\t\tvar y = s.labelFrequency.y != 0 ? -8 : 0;\n\t\t\n\t\tctx.font = \"16px Helvetica\";\n\t\t\n\t\tif (s.labelFrequency.x != 0) {\n\t\t\tx =  Math.max(s.offset.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.gridSize.x + ctx.measureText(s.domain.x + Math.floor(s.plotSize.x / s.gridSize.x) * s.unitPerTick.x).width * 0.5 - (s.offset.x + s.plotSize.x), 0);\n\t\t}\n\t\t\n\t\tctx.font = \"24px Helvetica\";\n\t\t\n\t\tif (s.xAxis != \"\")\n\t\t{ \n\t\t\tvar axisBleed = Math.max(((s.domain.y - s.domain.x) * s.pixelPerUnit.x * 0.5 + ctx.measureText(s.xAxis).width * 0.5) - ((s.domain.y - s.domain.x) * s.pixelPerUnit.x), 0);\n\t\t\tx = x > axisBleed ? x : axisBleed;\n\t\t}\n\t\t\n\t\tif (s.yAxis != \"\")\n\t\t{\n\t\t\tvar yLabelBleed = s.plotSize.y * 0.5 - ctx.measureText(s.yAxis).width * 0.5;\n\t\t\ty = yLabelBleed < y ? yLabelBleed : y;\n\t\t}\n\t\t\n\t\tlabelBleedVar.x = x;\n\t\tlabelBleedVar.y = y;\n\t}\n\t\n\treturn self;\n}\n\nmodule.exports = Plot;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plot.js\n ** module id = 3\n ** module chunks = 0\n **/","var Point = require('./point');\nvar Plot = require('./plot');\nvar Line = require('./line');\n\n/**\n * Creates a Plotter object. Given a HTML Canvas Element, this function creates\n * a series of functions for interacting with it. It also attaches some of\n * these functions to event listeners for mouse and touch events.\n *\n * @param {HTMLCanvasElement} canvas - The Canvas element that plots will be\n * drawn on.\n *\n * @param {Point} padding - a Point that describs how much padding\n * to apply to the canvas element before rendering elements.\n * \n * @return {Plotter} - An object that collects properties and methods for \n * interacting with the canvas element passed to the function.\n */\nfunction createPlotter()\n{\n\tvar canvas, ctx;\n\tvar plots = [];\n\tvar plotNames = {};\n\tvar currentPlot, clipped = false;\n\tvar debugBorders = false;\n\tvar padding = typeof arguments[1] !== \"undefined\" ? arguments[1] : new Point(0, 0);\n\t\n\tcanvas = arguments[0];\n\tctx = canvas.getContext(\"2d\");\n\t\t\n\tcanvas.addEventListener(\"mousedown\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"mousemove\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"mouseup\", function(e){updateMouse(e);}, false);\n\tcanvas.addEventListener(\"touchstart\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchmove\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchend\", function(e){updateTouch(e);}, false);\n\tcanvas.addEventListener(\"touchcancel\", function(e){updateTouch(e);}, false);\n\t\n\tfunction pageToPlot(p, plot)\n\t{\n\t\tvar s = plot.settings;\n\t\tvar x = (p.x - canvas.offsetLeft - s.offset.x) / s.pixelPerUnit.x + s.domain.x;\n\t\tvar y = (canvas.height - (p.y - canvas.offsetTop) - (canvas.height - (s.offset.y + s.plotSize.y))) / s.pixelPerUnit.y + s.range.x;\n\t\treturn new Point(x, y);\n\t}\n\t\n\tfunction pointInBounds(p, plot)\n\t{\n\t\tvar s = plot.settings;\n\t\treturn (p.x >= s.domain.x && p.x <= s.domain.y && p.y >= s.range.x && p.y <= s.range.y)\n\t}\n\t\n\tfunction findPlotUnderPoint(p)\n\t{\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\tif (pointInBounds(pageToPlot(p, plots[i]), plots[i]))\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n\t\n\tfunction updateMouse(e)\n\t{\n\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\tif (plot == -1)\n\t\t\treturn;\n\t\tplot = plots[plot];\n\t\t\n\t\tvar p = pageToPlot(new Point(e.pageX, e.pageY), plot);\n\t\tvar type = e.type.replace(\"mouse\", '');\n\t\t\n\t\tif ((type == \"down\" || type == \"move\") && (!(e.buttons & 1) && e.button != 0))\n\t\t\treturn;\n\t\t\n\t\tplot.mouse[type].x = p.x;\n\t\tplot.mouse[type].y = p.y;\n\t\tif (type == \"down\")\n\t\t{\n\t\t\tplot.mouse.isDown = true;\n\t\t\tplot.mouse.isUp = false;\n\t\t}\n\t\telse if (type == \"up\")\n\t\t{\n\t\t\tplot.mouse.isDown = false;\n\t\t\tplot.mouse.isUp = true;\n\t\t}\n\t}\n\t\n\tfunction updateTouch(e)\n\t{\t\n\t\tvar type = e.type.replace(\"touch\",'');\n\t\t\n\t\tfor(var i = 0; i < e.changedTouches.length; i++)\n\t\t{\n\t\t\tvar touchID, event;\n\t\t\t\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase \"start\":\n\t\t\t\t\tevent = new MouseEvent(\"mousedown\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tcase \"move\":\n\t\t\t\t\tevent = new MouseEvent(\"mousemove\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tcase \"cancel\":\n\t\t\t\tcase \"end\":\n\t\t\t\t\tevent = new MouseEvent(\"mouseup\",\n\t\t\t\t\t{screenX: e.changedTouches[i].screenX, screenY: e.changedTouches[i].screenY,\n\t\t\t\t\tclientX: e.changedTouches[i].clientX, clientY: e.changedTouches[i].clientY});\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcanvas.dispatchEvent(event);\n\t\t}\n\t\t\n\t\tif (e.touches.length > 0)\n\t\t{\n\t\t\tvar plot = findPlotUnderPoint(new Point(e.pageX, e.pageY));\n\t\t\tif (plot != -1)\n\t\t\t{\n\t\t\t\tplots[plot].mouse.isDown = true;\n\t\t\t\tplots[plot].mouse.isUp = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (e.touches.length == 1 && type == \"move\")\n\t\t\te.preventDefault();\n\t}\n\t\n\tfunction refitCanvas()\n\t{\n\t\tif (plots.length == 0)\n\t\t\treturn;\n\t\t\n\t\tif (clipped)\n\t\t{\n\t\t\tctx.restore();\n\t\t\tclipped = false;\n\t\t}\n\t\t\n\t\tvar size = new Point(0, 0);\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t{\n\t\t\tvar s = plots[i].settings;\n\t\t\tsize.x = Math.max(size.x, s.offset.x + s.plotSize.x + s.labelBleed.x);\n\t\t\tsize.y = Math.max(size.y, s.offset.y + s.plotSize.y + s.labelSize.y);\n\t\t}\t\t\t\n\t\tcanvas.width = size.x + padding.x + 10;\n\t\tcanvas.height = size.y + padding.y + 10;\n\t\t\n\t\tctx.strokeStyle = \"#0000FF\";\n\t\tctx.lineWidth = 2;\n\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\n\t\tfor (var i = 0; i < plots.length; i++)\n\t\t\tdrawPlot(plots[i]);\n\t}\n\t\n\t/**\n\t * Renders the specified plot on the canvas. This function takes a Plot\n\t * object and then uses its settings to draw it on the canvas.\n\t * @param  {Plot} plot - the Plot object we want to render on the canvas\n\t */\n\tfunction drawPlot(plot)\n\t{\n\t\tvar s = plot.settings;\n\t\t\n\t\tctx.translate(s.offset.x, s.offset.y);\n\t\tctx.clearRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\tif (debugBorders)\n\t\t{\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeRect(-s.labelSize.x, s.labelBleed.y, s.plotSize.x + s.labelSize.x + s.labelBleed.x, s.plotSize.y + s.labelSize.y - s.labelBleed.y);\n\t\t}\t\n\t\tctx.lineWidth = 2;\n\t\t\n\t\t//plot\n\t\tctx.fillStyle = \"#F8F8F8\";\n\t\tctx.fillRect(0, 0, s.plotSize.x, s.plotSize.y);\n\t\tctx.fillStyle = \"#000000\";\n\t\tctx.strokeStyle = \"#E0E0E0\";\n\t\tctx.font = \"16px Helvetica\";\n\t\tctx.textAlign = \"center\";\n\t\tctx.textBaseline = \"top\";\n\t\tctx.beginPath();\n\t\t\tfor( var i = 0; i <= s.plotSize.x / s.gridSize.x; i++)\n\t\t\t{\n\t\t\t\tvar x = i * s.gridSize.x;\n\t\t\t\tif (s.orientation==\"c\" || s.orientation==\"d\")\n\t\t\t\t\tx = s.plotSize.x - x;\n\t\t\t\t\n\t\t\t\tif (s.drawGrid)\n\t\t\t\t{\n\t\t\t\t\tctx.moveTo(x, s.plotSize.y);\n\t\t\t\t\tctx.lineTo(x, 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!(i % s.labelFrequency.x) && s.labelFrequency.x > 0)\n\t\t\t\t{\n\t\t\t\t\tvar tickLabel = s.domain.x + i * s.unitPerTick.x;\n\t\t\t\t\tctx.fillText( s.labelPrecision.x == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.x), x, s.plotSize.y + 5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.textAlign = \"right\";\n\t\t\tctx.textBaseline = \"middle\";\n\t\t\tfor( var i = 0; i <= s.plotSize.y / s.gridSize.y; i++)\n\t\t\t{\n\t\t\t\tvar y = i * s.gridSize.y;\n\t\t\t\tif (!(s.orientation==\"b\" || s.orientation==\"c\"))\n\t\t\t\t\ty = s.plotSize.y - y;\t\n\t\t\t\tif (s.drawGrid)\n\t\t\t\t{\n\t\t\t\t\tctx.moveTo(0, y);\n\t\t\t\t\tctx.lineTo(s.plotSize.x, y);\n\t\t\t\t}\n\t\t\t\tif (!(i % s.labelFrequency.y) && s.labelFrequency.y > 0)\n\t\t\t\t{\n\t\t\t\t\tvar tickLabel = s.range.x + i * s.unitPerTick.y;\n\t\t\t\t\tctx.fillText(s.labelPrecision.y == -1 ? tickLabel : tickLabel.toFixed(s.labelPrecision.y), -5, y);\n\t\t\t\t}\n\t\t\t}\n\t\tctx.stroke();\n\t\t\n\t\t//axis\n\t\tctx.strokeStyle = \"#000000\";\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\t\tvar axisOffset = new Point(\n\t\t\t(s.zeroBoundAxis ? Math.max(0, Math.min(s.plotSize.x, ((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : -s.domain.x) * s.pixelPerUnit.x)) : (s.orientation==\"c\"||s.orientation==\"d\") ? s.plotSize.x : 0),\n\t\t\t(s.zeroBoundAxis ? Math.min(s.plotSize.y, Math.max(0, ((s.orientation==\"b\"||s.orientation==\"c\") ? -s.range.x : s.range.y) * s.pixelPerUnit.y)) : (s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.plotSize.y));\n\t\t\tctx.moveTo(axisOffset.x, 0);\n\t\t\tctx.lineTo(axisOffset.x, s.plotSize.y);\n\t\t\tctx.moveTo(0, axisOffset.y);\n\t\t\tctx.lineTo(s.plotSize.x, axisOffset.y);\n\t\tctx.stroke();\n\t\t\n\t\t//x axis label\n\t\tctx.textAlign = \"center\";\n\t\tctx.textBaseline = \"bottom\";\n\t\tctx.font = \"24px Helvetica\";\n\t\tctx.fillText(s.xAxis, s.plotSize.x * 0.5, s.plotSize.y + s.labelSize.y);\n\t\t\n\t\t//y axis label\n\t\tctx.translate(-s.labelSize.x,  s.plotSize.y * 0.5);\n\t\tctx.rotate(3 * Math.PI * 0.5);\n\t\tctx.textBaseline = \"top\";\n\t\tctx.fillText(s.yAxis, 0, 0);\n\t\tctx.rotate(-3 * Math.PI * 0.5);\n\t\tctx.translate(s.labelSize.x,  -(s.plotSize.y * 0.5));\n\t\t\n\t\t//coordinates\n\t\tif (s.drawCoords) //needs to be redone entirely\n\t\t{\n\t\t\tvar coordOffsetY = Math.max(ctx.measureText(s.domain.x).width, ctx.measureText(s.domain.y).width);\n\t\t\tvar coordOffsetX = coordOffsetY * 2 + ctx.measureText(\"y: \").width;\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.textBaseline = \"bottom\";\n\t\t\tctx.fillText(\"x: \" + (isNaN(Math.round(this.mouse.move.x)) ? 0 : Math.round(this.mouse.move.x)), s.plotSize.x - coordOffsetX - 20, s.plotSize.y + s.labelSize.y);\n\t\t\tctx.fillText(\"y: \" + (isNaN(Math.round(this.mouse.move.y)) ? 0 : Math.round(this.mouse.move.y)), s.plotSize.x - coordOffsetY - 10, s.plotSize.y + s.labelSize.y);\n\t\t}\n\t\t\n\t\tctx.translate(-s.offset.x, -s.offset.y);\n\t}\n\t\n\treturn {\n\t\tset drawBorders(value) { debugBorders = value; },\n\t\tget drawBorders() { return debugBorders; },\n\t\tnewPlot: function(settings, name)\n\t\t{\n\t\t\tplot = new Plot(settings, ctx);\n\t\t\tplots.push(plot);\n\t\t\t\n\t\t\tif (typeof name !== \"undefined\")\n\t\t\t\tplotNames[name] = plots.length - 1;\n\t\t\t\n\t\t\trefitCanvas();\n\t\t\tdrawPlot(plot);\n\t\t\t\n\t\t\treturn plots.length - 1;\n\t\t},\n\t\tclearPlot: function(unclip)\n\t\t{\n\t\t\tunclip = typeof unclip !== \"undefined\" ? unclip : false;\n\t\t\t\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped && unclip)\n\t\t\t\tctx.restore();\n\t\t\t\n\t\t\tdrawPlot(currentPlot);\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t}\n\t\t},\n\t\teditPlot: function(plot, settings, reCalcLabels, redrawCanvas)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\n\t\t\tredrawCanvas = typeof redrawCanvas !== \"undefined\" ? redrawCanvas : false;\n\t\t\treCalcLabels = typeof reCalcLabels !== \"undefined\" ? reCalcLabels : false;\n\t\t\t\n\t\t\tif (plot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t\tctx.restore();\n\t\t\t\n\t\t\tif (redrawCanvas)\n\t\t\t{\n\t\t\t\tctx.clearRect(0,0, canvas.width, canvas.height);\n\t\t\t\tctx.strokeStyle = \"#0000FF\";\n\t\t\t\tctx.lineWidth = 2;\n\t\t\t\tctx.strokeRect(0, 0, canvas.width, canvas.height);\n\t\t\t}\n\t\t\t\n\t\t\tfor (var key in settings)\n\t\t\t\tif (plot.settings.hasOwnProperty(key))\n\t\t\t\t\tplot.settings[key] = settings[key];\n\t\t\t\n\t\t\tif (reCalcLabels)\n\t\t\t\tplot.reCalculateLabels();\n\t\t\t\n\t\t\tdrawPlot(plot);\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t}\n\t\t},\n\t\tselectPlot: function(plot, clear, clip)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && (plot < 0 || plot > plots.length - 1))\n\t\t\t\treturn;\n\t\t\t\n\t\t\tclear = typeof clear !== \"undefined\" ? clear : true;\n\t\t\tclip = typeof clip !== \"undefined\" ? clip : true;\n\t\t\tplot = (typeof plot === \"number\" ? plots[plot] : ((typeof plot === \"string\" || plot instanceof String || plot.constructor == String || Object.prototype.toString.call(plot) == \"[object String]\") ? plots[plotNames[plot]] : plot));\n\t\t\t\n\t\t\tif (plot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (clipped)\n\t\t\t\tctx.restore();\n\t\t\tcurrentPlot = plot;\n\t\t\tif (clear)\n\t\t\t\tdrawPlot(currentPlot);\n\t\t\t\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tctx.save();\n\t\t\t\tctx.rect(currentPlot.settings.offset.x + 1, currentPlot.settings.offset.y, currentPlot.settings.plotSize.x - 1, currentPlot.settings.plotSize.y - 1);\n\t\t\t\tctx.clip();\n\t\t\t\tclipped = true;\n\t\t\t}\n\t\t\telse if (clipped)\n\t\t\t\tclipped = false;\n\t\t},\n\n\n\t\tget ctx() { \n\t\t\treturn ctx; },\n\n\n\t\tget mouse()\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\treturn currentPlot.mouse;\n\t\t},\n\n\n\t\tget settings()\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\treturn currentPlot.settings;\n\t\t},\n\n\n\t\tpointOnPlot: function(p, plot)\n\t\t{\n\t\t\tif (typeof plot === \"number\" && \n\t\t\t   (plot >= 0 && plot <= plots.length - 1)) {\n\t\t\t\t\tplot = plots[plot];\n\t\t\t}\n\t\t\telse if (typeof plot === \"string\" || \n\t\t\t\t\t plot instanceof String || \n\t\t\t\t\t Object.prototype.toString.call(plot) == \"[object String]\") {\n\n\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t}\n\t\t\telse if (plot.hasOwnProperty('constructor') && plot.constructor == String) {\n\t\t\t\tplot = plots[plotNames[plot]];\n\t\t\t}\n\t\t\telse\n\t\t\t\tplot = currentPlot;\n\t\t\t\n\t\t\treturn pointInBounds(p, plot);\n\t\t},\n\n\n\t\tplotToCanvas: function(p)\n\t\t{\n\t\t\tvar s = currentPlot.settings;\n\t\t\tvar x = (((s.orientation==\"c\"||s.orientation==\"d\") ? s.domain.y : 2 * p.x) - p.x - ((s.orientation==\"c\"||s.orientation==\"d\") ? 0 : s.domain.x)) * s.pixelPerUnit.x + s.offset.x;\n\t\t\tvar y = s.plotSize.y - ((((s.orientation==\"b\"||s.orientation==\"c\") ? s.range.y : 2 * p.y) - p.y - ((s.orientation==\"b\"||s.orientation==\"c\") ? 0 : s.range.x)) * s.pixelPerUnit.y) + s.offset.y;\n\t\t\treturn new Point(x, y);\n\t\t},\n\n\n\t\tplotPoint: function(p, r, fill)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tr = typeof r !== \"undefined\" ? r : 2;\n\t\t\tfill = typeof fill !== \"undefined\" ? fill : true;\n\t\t\t\n\t\t\tp = this.plotToCanvas(p);\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n\t\t\tif (fill)\n\t\t\t\tctx.fill();\n\t\t\telse\n\t\t\t\tctx.stroke();\n\t\t},\n\n\n\t\tplotLine: function(p1, p2)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tp1 = this.plotToCanvas(p1);\n\t\t\tp2 = this.plotToCanvas(p2);\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\tplotSlope: function(p, slope)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tvar p1 = new Point(currentPlot.settings.domain.x, p.y - slope * (p.x - currentPlot.settings.domain.x));\n\t\t\tif (!pointInBounds(p1, currentPlot))\n\t\t\t{\n\t\t\t\tp1.y = p1.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\tp1.x = p.x - (p.y - p1.y)/slope;\n\t\t\t}\n\t\t\tvar p2 = new Point(currentPlot.settings.domain.y, p.y - slope * (p.x - currentPlot.settings.domain.y));\n\t\t\tif (!pointInBounds(p2, currentPlot))\n\t\t\t{\n\t\t\t\tp2.y = p2.y < currentPlot.settings.range.x ? currentPlot.settings.range.x : currentPlot.settings.range.y;\n\t\t\t\tp2.x = p.x - (p.y - p2.y)/slope;\n\t\t\t}\n\t\t\tthis.plotLine(p1, p2);\n\t\t\t\n\t\t\treturn new Line(p1, p2, slope, new Point(p.x, p.y));\n\t\t},\n\n\n\t\t/**\n\t\t * Take an array of vertices and add them to the plot sequentially.\n\t\t * When all of them have been added, draw them on the canvas.\n\t\t * \n\t\t * @param  {Array.<Point>} points - an array that contains all of the \n\t\t * vertices of the polygon. They will be plotted in the order they are\n\t\t * listed in the array.\n\t\t * \n\t\t * @param  {[boolean]} closed - a boolean value that specifies whether \n\t\t * the vertices should be connected when the plot is rendered. By\n\t\t * default, the vertices will not be rendered.\n\t\t */\n\t\tplotPoly: function(points, closed)\n\t\t{\n\t\t\tvar length = Object.keys(points).length;\n\t\t\tif (currentPlot == undefined || length < 2)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tclosed = typeof closed !== \"undefined\" ? closed : false;\n\t\t\t\n\t\t\tif (typeof points == \"undefined\")\n\t\t\t\treturn;\n\t\t\t\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < length - 1; i++)\n\t\t\t\t{\n\t\t\t\t\tvar p = this.plotToCanvas(points[i]);\n\t\t\t\t\t\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t}\n\t\t\t\tif (closed)\n\t\t\t\t{\n\t\t\t\t\tvar p = this.plotToCanvas(points[0]);\n\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t}\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\t/**\n\t\t * Given a mathematical function, render it on a plot. This function\n\t\t * iterates from the start value to the end value. At each point, it\n\t\t * calculates the point at that value using the given function.\n\t\t * \n\t\t * @param  {Function} func - the function we want to plot on the graph.\n\t\t * It takes a numeric value as a parameter and returns a numeric value.\n\t\t * \n\t\t * @param  {[boolean]} xFunc - this specifies whether the function is\n\t\t * to be graphed along the x-axis or the y-axis. It's default value is\n\t\t * true.\n\t\t * \n\t\t * @param  {[number]} step - the value to increment by when calculating\n\t\t * function points. By default, it will increment by 1.\n\t\t * \n\t\t * @param  {[number]} start - this is the value that the function will\n\t\t * start calculating values at. By default, it will use the start value\n\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t * \n\t\t * @param  {[number]} end - this is the value that the function will\n\t\t * stop calculating values at. By default, it will use the end value\n\t\t * of the plot's domain (if an xFunc) or range (if not an xFunc)\n\t\t */\n\t\tplotFunction: function(func, xFunc, step, start, end)\n\t\t{\n\t\t\tif (currentPlot == undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txFunc = typeof xFunc !== \"undefined\" ? xFunc : true;\n\t\t\tstep = typeof step !== \"undefined\" ? step : 1;\n\t\t\tstart = typeof start !== \"undefined\" ? start : (xFunc ? currentPlot.settings.domain.x : currentPlot.settings.range.x);\n\t\t\tend = typeof end !== \"undefined\" ? end : (xFunc ? currentPlot.settings.domain.y : currentPlot.settings.range.y);\n\n\t\t\tvar i = start, funcValue;\n\t\t\tvar points = [];\n\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.beginPath();\n\n\t\t\t\t/*\n\t\t\t\t * This loops iterates, adding the amount specified by timestep\n\t\t\t\t * value to the count each time. At each time. If the value exists,\n\t\t\t\t * it draws a line to the new location. It does this until the value\n\t\t\t\t * of the count is greater than or equal to the end value.\n\t\t\t\t */\n\t\t\t\twhile (i < end)\n\t\t\t\t{\n\t\t\t\t\tfuncValue = func(i);\n\t\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t\tvar p = new Point(xFunc?i:funcValue, xFunc?funcValue:i);\n\t\t\t\t\t\tp = this.plotToCanvas(p);\t\t\n\t\t\t\t\t\tif (i != start) {\n\t\t\t\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+= step;\n\t\t\t\t\tif (i > end) {\n\t\t\t\t\t\ti = end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * an edge case. In the event that start is greater than or\n\t\t\t\t * equal to end, plot that point\n\t\t\t\t */\n\t\t\t\tif (typeof funcValue !== \"undefined\") {\n\t\t\t\t\t//points.push(new Point(xFunc?i:funcValue, xFunc?funcValue:i));\n\t\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t},\n\n\n\t\t/** \n\t\t * If a plot is currently specified, draw the text at the specified\n\t\t * point on the plot.\n\t\t * @param  {string} text  - The text the user wants to write on the canvas\n\t\t * @param  {Point} point  - The point, in the plot's local coordinate\n\t\t * system, that the text will be rendered at.\n\t\t */\n\t\tplotText: function(text, point)\n\t\t{\n\t\t\tif (currentPlot == undefined)\n\t\t\t\treturn;\n\t\t\tpoint = typeof point !== \"undefined\" ? point : new Point(currentPlot.settings.domain.x + (currentPlot.settings.domain.y - currentPlot.settings.domain.x) * 0.5, currentPlot.settings.range.x + (currentPlot.settings.range.y - currentPlot.settings.range.x) * 0.5);\n\t\t\tpoint = this.plotToCanvas(point);\n\t\t\tctx.fillText(text, point.x, point.y);\n\t\t},\n\n\n\t\t/**\n\t\t * Print the plot data of the pointObject as CSV. The function accepts\n\t\t * a PointObject, retrives its points and parses the specified fields\n\t\t * as a CSV file. If no fields are specified, the function will print\n\t\t * all of them.\n\t\t *\n\t\t * @param  {PointObject} pointObject - the object from which plotter\n\t\t * retrieves the points.\n\t\t * @param  {[Array]} fields - an array of the fields to display\n\t\t */\n\t\tprintPlotData: function(pointObject, fields) {\n\t\t\tvar csv = \"\";\n\t\t\tvar points = pointObject.getPoints();\n\t\t\tvar header = fields ? fields : Object.keys(points[0]);\n\t\t\t\n\t\t\tvar point = {};\n\t\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\t\tpoint = points[i];\n\t\t\t\tif (i === 0) {\t\n\t\t\t\t\tfor(var j = 0; j < header.length; j++) {\n\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsv += header[j];\n\t\t\t\t\t}\n\t\t\t\t\tcsv += \"\\n\";\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < header.length; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tcsv += \",\";\n\t\t\t\t\t}\n\t\t\t\t\tcsv += point[header[j]];\n\t\t\t\t}\n\t\t\t\tcsv += \"\\n\";\n\t\t\t}\n\t\t\twindow.open(\"data:text/csv;charset=utf-8,\" + encodeURIComponent(csv));;\n\t\t}\n\t}\n}\n\nmodule.exports = createPlotter;\n// function createPlotter() {\n// \treturn Plotter.apply(this, arguments;\n// }\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/plotter.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}